# Rterm.exe --vanilla

library(Homo.sapiens) 

load(file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/XHMMcnvAndGATKcnvWithQAandQS.rda")

GATKcnv <- GATKcnv[-which(GATKcnv$del_1.dup_2 == 0),] # nrow(GATKcnv[-which(GATKcnv$del_1.dup_2 == 0),])# = 48051 # which(GATKcnv$del_1.dup_2 == 0) = 41003
# remove segment with QS Phred < 20

GATKcnv <- GATKcnv[which(as.numeric(GATKcnv$PhredMinOnePtAgrees) > 20),] # nrow(GATKcnv[-which(GATKcnv$del_1.dup_2 == 0),])# = 48051 # length(which(GATKcnv$PhredMinOnePtAgrees > 20)) = 34259
# nrow(GATKcnv) after above steps = 28191

# i have to separate based on del or dup otherwise overlap is called between deletion in one individual and duplication in another individual

GATKcnvDel <- GATKcnv[which(GATKcnv$del_1.dup_2 == 1),]  # nrow = 22745

#################### 

A <- makeGRangesFromDataFrame(GATKcnvDel, keep.extra.columns=TRUE)

Alaps <- findOverlaps(A, drop.self=TRUE)
Asect <- pintersect(A[queryHits(Alaps)], A[subjectHits(Alaps)])
Aunion <- punion(A[queryHits(Alaps)], A[subjectHits(Alaps)])

# mergeByOverlaps may be a function worth trying... mergeByOverlaps(A)

GATKcharacter <- data.frame(
                sample = A$sample[queryHits(Alaps)],
                chr = as.data.frame(A)$seqnames[queryHits(Alaps)],
                queryStart = as.data.frame(A)$start[queryHits(Alaps)],
                queryEnd = as.data.frame(A)$end[queryHits(Alaps)],
                subjectStart = as.data.frame(A)$start[subjectHits(Alaps)],
                subjectEnd = as.data.frame(A)$end[subjectHits(Alaps)],
                query=queryHits(Alaps), 
                subject= subjectHits(Alaps),
                subjectSample = A$sample[subjectHits(Alaps)],
                intersection_width=width(Asect), 
                union_width=width(Aunion),
                pctOverlap = round(width(Asect)/width(Aunion), 2),
                query.del_1.dup_2 = as.data.frame(A)$del_1.dup_2[queryHits(Alaps)],
                subject.del_1.dup_2 = as.data.frame(A)$del_1.dup_2[subjectHits(Alaps)],
                queryPhredQA = as.data.frame(A)$PhredAllPtsAgree[queryHits(Alaps)],
                subjectPhredQA = as.data.frame(A)$PhredAllPtsAgree[subjectHits(Alaps)],
                queryPhredQS = as.data.frame(A)$PhredMinOnePtAgrees[queryHits(Alaps)],
                subjectPhredQS = as.data.frame(A)$PhredMinOnePtAgrees[subjectHits(Alaps)])
  
  # freq <- table(GATKcharacter$pctOverlap)
  # dens5 <- density(freq5$Freq,  kernel = c("gaussian", "epanechnikov", "rectangular", "triangular", "biweight", "cosine", "optcosine")[1])
  # df <- rbind(freq1.1, freq2.1, freq3.1, freq4.1, freq5)

# install.packages("car")
library(car)
png(file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/densityByFilterStep.png")
  plot(freq, main = "Density of per gene calls for each filter step", col = 1)
    lines(dens2, col = 2) 
    legend("topright", legend = c("Deletions from Both Callers", 
                                 "Exluding Married-Ins",
                                 "gnomAD AF < 0.05",
                                 "Greater than 2 Indidivuduals",
                                 "Greater than 2 Families with 2 per Family"),
                                  lty = 1, col = 1:5)
                                  
  # just looking at the data.frame
  # GATKcharacter[1:205,]
  # length(unique(GATKcharacter$query))
  # Alapsframe <- as.data.frame(Alaps)
 
 # change GATKcharacter to gchar so I can easily refresh it after the loop screws it up
 gchar <- GATKcharacter
 # GATKcharacter <- gchar
 # set up to loop through GATKcharacter and exatract matches just one time per genomic cooridinates by eliminating queries once they are recorded as subjects
  
  uniqueCNV <- data.frame(matrix(nrow = 0, ncol=8))
  colnames(uniqueCNV) = c("chr", "start", "end", "del_1.dup_2", "numb_G75pctOverlap", "numb_G90pctOverlap", "numb_G95pctOverlap", "width") 
for(i in unique(GATKcharacter$query)) { # i = 1
      if(i %in% GATKcharacter$query){
      instance <- data.frame(chr = GATKcharacter$chr[which(GATKcharacter$query==i)][1],  #as.data.frame(A)
                  start = GATKcharacter$queryStart[which(GATKcharacter$query==i)][1],
                  end = GATKcharacter$queryEnd[which(GATKcharacter$query==i)][1],
                  del_1.dup_2 = GATKcharacter$query.del_1.dup_2[which(GATKcharacter$query==i)][1], 
                  # add 1 to number of overlaps to identify the number of segments with those coordinates including self
                  numb_Overlap = length(which(GATKcharacter$query==i))+1,
                  numb_G0pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] <= 0.25)),
                  numb_G25pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] > 0.25 & GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] <= 0.50)),
                  numb_G50pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] > 0.50 & GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] <= 0.75)),
                  numb_G75pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] > 0.75 & GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] <= 0.90)),
                  numb_G90pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)]>0.90 && GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] <= 0.95)),
                  numb_G95pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)]>0.95))+1,
                  width = GATKcharacter$queryEnd[which(GATKcharacter$query==i)][1] - GATKcharacter$queryStart[which(GATKcharacter$query==i)][1])
                  
         cat("CNV ", i, " with ", instance$numb_Overlap, "overlaps\n") 
   # remove the queries from the data.frame that are covered as subject hits with an earlier query with at least 75% overlap 
   GATKcharacter <- GATKcharacter[-which(GATKcharacter$query %in% GATKcharacter$subject[which(GATKcharacter$query==i & GATKcharacter$pctOverlap > 0.75)]),]
    
    uniqueCNV <- rbind(uniqueCNV, instance)
      } # if i in GATKcharacter$query
    } # for i

    
    write.csv(uniqueCNV, file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/10.19.21.GATKdeletionsSelfOverlap.csv")
 ######################################################################################################################
 # separated based on del or dup so that overlaps called as one are not considered as the same in the other
 # GATK duplications
 
 GATKcnvDup <- GATKcnv[which(GATKcnv$del_1.dup_2 == 2),] 

A <- makeGRangesFromDataFrame(GATKcnvDup, keep.extra.columns=TRUE)

Alaps <- findOverlaps(A, drop.self=TRUE)
Asect <- pintersect(A[queryHits(Alaps)], A[subjectHits(Alaps)])
Aunion <- punion(A[queryHits(Alaps)], A[subjectHits(Alaps)])

# mergeByOverlaps may be a function worth trying... mergeByOverlaps(A)

GATKcharacter <- data.frame(
                sample = A$sample[queryHits(Alaps)],
                chr = as.data.frame(A)$seqnames[queryHits(Alaps)],
                queryStart = as.data.frame(A)$start[queryHits(Alaps)],
                queryEnd = as.data.frame(A)$end[queryHits(Alaps)],
                subjectStart = as.data.frame(A)$start[subjectHits(Alaps)],
                subjectEnd = as.data.frame(A)$end[subjectHits(Alaps)],
                query=queryHits(Alaps), 
                subject= subjectHits(Alaps),
                subjectSample = A$sample[subjectHits(Alaps)],
                intersection_width=width(Asect), 
                union_width=width(Aunion),
                pctOverlap = round(width(Asect)/width(Aunion), 2),
                query.del_1.dup_2 = as.data.frame(A)$del_1.dup_2[queryHits(Alaps)],
                subject.del_1.dup_2 = as.data.frame(A)$del_1.dup_2[subjectHits(Alaps)],
                queryPhredQA = as.data.frame(A)$PhredAllPtsAgree[queryHits(Alaps)],
                subjectPhredQA = as.data.frame(A)$PhredAllPtsAgree[subjectHits(Alaps)],
                queryPhredQS = as.data.frame(A)$PhredMinOnePtAgrees[queryHits(Alaps)],
                subjectPhredQS = as.data.frame(A)$PhredMinOnePtAgrees[subjectHits(Alaps)])
  
# change GATKcharacter to gchar so I can easily refresh it after the loop screws it up
 gchar <- GATKcharacter
 # GATKcharacter <- gchar
 # set up to loop through GATKcharacter and exatract matches just one time per genomic cooridinates by eliminating queries once they are recorded as subjects
  
uniqueCNV <- data.frame(matrix(nrow = 0, ncol=8))
  colnames(uniqueCNV) = c("chr", "start", "end", "del_1.dup_2", "numb_Overlap", "numb_0to25pctOverlap", "numb_25to50pctOverlap","numb_50to75pctOverlap", "numb_G75pctOverlap", "numb_G90pctOverlap", "numb_G95pctOverlap", "width") 
  
  for(i in unique(GATKcharacter$query)) { # i = 1
      if(i %in% GATKcharacter$query){
      instance <- data.frame(chr = GATKcharacter$chr[which(GATKcharacter$query==i)][1],  #as.data.frame(A)
                  start = GATKcharacter$queryStart[which(GATKcharacter$query==i)][1],
                  end = GATKcharacter$queryEnd[which(GATKcharacter$query==i)][1],
                  del_1.dup_2 = GATKcharacter$query.del_1.dup_2[which(GATKcharacter$query==i)][1], 
                  # add 1 to number of overlaps to identify the number of segments with those coordinates including self
                  numb_Overlap = length(which(GATKcharacter$query==i))+1,
                  numb_0to25pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] <= 0.25)),
                  numb_25to50pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] > 0.25 & GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] <= 0.50)),
                  numb_50to75pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] > 0.50 & GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] <= 0.75)),
                  numb_G75pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)] > 0.75 )),
                  numb_G90pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)]>0.90 )),
                  numb_G95pctOverlap = length(which(GATKcharacter$pctOverlap[which(GATKcharacter$query==i)]>0.95))+1,
                  width = GATKcharacter$queryEnd[which(GATKcharacter$query==i)][1] - GATKcharacter$queryStart[which(GATKcharacter$query==i)][1])
                  
         cat("CNV ", i, " with ", instance$numb_Overlap, "overlaps\n") 
   # remove the queries from the data.frame that are covered as subject hits with an earlier query with at least 75% overlap
   GATKcharacter <- GATKcharacter[-which(GATKcharacter$query %in% GATKcharacter$subject[which(GATKcharacter$query==i & GATKcharacter$pctOverlap > 0.75)]),]
    
    # GATKcharacter[which(GATKcharacter$query==i),]
    uniqueCNV <- rbind(uniqueCNV, instance)
      } # if i in GATKcharacter$query
    } # for i
    
    write.csv(uniqueCNV, file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/10.19.21.GATKDuplicationsSelfOverlap.csv")

# now findOverlaps with original file to identify all of those singleton calls?

######################################################################################################################
###### XHMM characterization











##########################################################################################################################
#########characterizing the XHMM and GATK overlap
# find overlaps between XHMM and GATK, BUT first subset to only deletions to avoid a CNV called as deletion in one is classed as duplication in the other.
# subset for deletions only: 
GATKcnv <- subset(GATKcnv, GATKcnv$del_1.dup_2 == 1) # nrow(GATKcnv) = 89054 --> 29206
XHMMcnv <- subset(XHMMcnv, XHMMcnv$del_1.dup_2 ==1) # nrow(XHMMcnv) = 11550 --> 5673


for(i in unique(GATKcnv$sample)){                      #i = GATKcnv$sample[1]
A <- FALSE
B <- FALSE

A <- makeGRangesFromDataFrame(subset(GATKcnv, GATKcnv$sample == i), keep.extra.columns=TRUE) 
if(any(XHMMcnv$sample == i)){
B <- makeGRangesFromDataFrame(subset(XHMMcnv, XHMMcnv$sample == i), keep.extra.columns=TRUE)

    ABlaps <- findOverlaps(A, B)
    ABsect <- pintersect(A[queryHits(ABlaps)], B[subjectHits(ABlaps)])
    ABunion <- punion(A[queryHits(ABlaps)], B[subjectHits(ABlaps)])

   ##################################### GATK vs. XHMM CALLS TO SUBSET BY SAMPLE/INDIVIDUAL#####################################
    GATKandXHMM <- data.frame(
                sample = A$sample[queryHits(ABlaps)],
                chr = as.data.frame(A)$seqnames[queryHits(ABlaps)],
                GATKstart = as.data.frame(A)$start[queryHits(ABlaps)],
                GATKend = as.data.frame(A)$end[queryHits(ABlaps)],
                XHMMstart = as.data.frame(B)$start[subjectHits(ABlaps)],
                XHMMend = as.data.frame(B)$end[subjectHits(ABlaps)],
                query = queryHits(ABlaps), 
                subject = subjectHits(ABlaps),
                intersection_width = width(ABsect), 
                union_width = width(ABunion),
                pctOverlap = round(width(ABsect)/width(ABunion), 2),
                GATKcall.copyNum = as.data.frame(A)$copyNum[queryHits(ABlaps)],
                GATKPhred = A$PhredMinOnePtAgrees[queryHits(ABlaps)],
                XHMMPhred = B$PhredMinOnePtAgrees[subjectHits(ABlaps)])
                
    write.table(GATKandXHMM, file=paste("C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/callsInCommonGATKandXHMMpluScopyNum/10.19.21.GATKandXHMM.", i, ".csv", sep=""), row.names=FALSE, sep=",") #quote=c(1:3)???
    } else {
        cat("no.olaps in ", i)
        GATKandXHMM <- data.frame(
                sample ="no.olaps",
                chr = "no.olaps",
                GATKstart = "no.olaps",
                GATKend = "no.olaps",
                XHMMstart = "no.olaps",
                XHMMend = "no.olaps",
                query = "no.olaps",
                subject = "no.olaps",
                intersection_width = "no.olaps",
                union_width = "no.olaps",
                pctOverlap = "no.olaps",
                GATKcall.copyNum = "no.olaps",
                GATKPhred = "no.olaps",
                XHMMPhred = "no.olaps")
            write.table(GATKandXHMM, file=paste("C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/callsInCommonGATKandXHMMpluScopyNum/10.19.21.GATKandXHMM.", i, ".csv", sep=""), row.names=FALSE, sep=",")           
            } # else

} # end of loop

##create new data.frame with overlapping cnvs + copyNum

overlappingCNVs <- matrix(nrow=0, ncol=17)
overlappingCNVs <- as.data.frame(overlappingCNVs)
colnames(overlappingCNVs) <- c("sample", "chr", "GATKstart", "GATKend", "XHMMstart", "XHMMend", 
                                "query", "subject", "intersection_width", "union_width", "pctOverlap",
                                "GATKcall.copyNum", "GATKPhred", "XHMMPhred")
i=0
for(i in unique(GATKcnv$sample)){                      #i = GATKcnv$sample[1]
  
  GATKandXHMM <- read.csv(file = paste("C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/callsInCommonGATKandXHMMpluScopyNum/10.19.21.GATKandXHMM.", i, ".csv", sep=""))
  cat(GATKandXHMM[1,1], "\n")
  overlappingCNVs <- rbind(overlappingCNVs, GATKandXHMM)
}

write.table(overlappingCNVs, file=paste("C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/10.19.21.compositeOfCNVsCalledByGATKandXHMM", ".csv", sep=""), row.names=FALSE, sep=",")
overlappingCNVs <- read.csv(file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/10.19.21.compositeOfCNVsCalledByGATKandXHMM.csv")

overlappingCNVs

hist(as.numeric(overlappingCNVs$pctOverlap), main= "Percent Overlap between deletion calls in XHMM and GATK4 by sample", 
      xlab = "percent overlap", ylab = "frequency",
      col = 5, border = 1, breaks = 4)









