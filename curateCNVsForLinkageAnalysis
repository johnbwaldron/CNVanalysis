#Rterm.exe --vanilla

library(Homo.sapiens) 

####################################################################################################
###################################FUNCTIONS########################################################
#Find overlap
splitByOverlap <-
    function(query, subject, column="ENTREZID", ...)
{
    olaps <- findOverlaps(query, subject, ...)
    f1 <- factor(subjectHits(olaps),
                 levels=seq_len(subjectLength(olaps)))
    splitAsList(mcols(query)[[column]][queryHits(olaps)], f1)
}

geneRanges <- 
    function(db, column="ENTREZID")
{
    g <- genes(db, columns=column) #, single.strand.genes.only=ss) # No matter what I do, including single.strand.genes.only= FALSE returns: Error in .local(x, ...) : unused argument (single.strand.genes.only = FALSE)
    col <- mcols(g)[[column]]
    genes <- granges(g)[rep(seq_along(g), elementNROWS(col))]
    mcols(genes)[[column]] <- as.character(unlist(col))
    genes
}

# try creating a different function in order to include even those genes with exons on both strands (some 400+) transcripts() or exons() or cds()
## does not work yet
transcriptRanges <- 
    function(db, column="ENTREZID")
{
    t <- transcripts(db, columns=column) # t <- transcripts(Homo.sapiens, column="SYMBOL")
    col <- mcols(t)[[column]]
    transcripts <- granges(t)[rep(seq_along(t), elementNROWS(col))]
    mcols(transcripts)[[column]] <- as.character(unlist(col))
    transcripts
}

# try creating a CDS function, that should be restiricted to one strand and incdlude only protein coding sequences
cdsRanges <- 
    function(db, column="ENTREZID")
{
    c <- cds(db, columns=column) 
    col <- mcols(c)[[column]]
    CDS <- granges(c)[rep(seq_along(c), elementNROWS(col))]
    mcols(CDS)[[column]] <- as.character(unlist(col))
    CDS
}
####################################################################################################


########################## starting from scratch.
########################## for careful comparison of deletion and duplication calls PRIOR to checking for overlap between calls
########################## for implementation of appropriate quality scores PRIOR to inclusion of CNV calls in analysis
# for previous (9/28/21) GATK output combined int one table, see CNVanalysis/blob/main/individualGATKgenotypeCallsToOneTable
# redo process of combining important GATK calls into one table with quality scores:
##FORMAT=<ID=CN,Number=1,Type=Integer,Description="Segment most-likely copy-number call">
##FORMAT=<ID=GT,Number=1,Type=Integer,Description="Segment genotype">
##FORMAT=<ID=NP,Number=1,Type=Integer,Description="Number of points (i.e. targets or bins) in the segment">
##FORMAT=<ID=QA,Number=1,Type=Integer,Description="Complementary Phred-scaled probability that all points (i.e. targets or bins) in the segment agree with the segment copy-number call">
##FORMAT=<ID=QS,Number=1,Type=Integer,Description="Complementary Phred-scaled probability that at least one point (i.e. target or bin) in the segment agrees with the segment copy-number call">
##FORMAT=<ID=QSE,Number=1,Type=Integer,Description="Complementary Phred-scaled probability that the segment end position is a genuine copy-number changepoint">
##FORMAT=<ID=QSS,Number=1,Type=Integer,Description="Complementary Phred-scaled probability that the segment start position is a genuine copy-number changepoint">
## GT:CN:NP:QA:QS:QSE:QSS	0:2:1:67:67:67:67 ####### df <- read.delim(file= paste("C:/Users/jwaldr/OneDrive - LSUHSC/Literature/genotyped/unzipped/genotyped-segments-cohort203-sample.", i, ".vcf", sep = ""), colClasses = "character") 

files = list.files(path = "C:/Users/jwaldr/OneDrive - LSUHSC/Literature/genotyped/unzipped/", pattern = "^.*(.vcf)$")

# make dataframe with columns = "sample", "chr", "start", "end", "del_1.dup_2", "copyNum", "PhredAllPtsAgree", "PhredMinOnePtAgrees" 
GATKresults <- data.frame(sample="0", chr="0", ID="0", X ="0")[-1,]


for(i in 1:202){ # i = 50
           # note sample 0 only shows CNVs in chr 1, something is likely wrong with this
           df <- read.delim(file= paste("C:/Users/4wald/OneDrive - LSUHSC/Literature/genotyped/unzipped/genotyped-segments-cohort203-sample.", i, ".vcf", sep = ""), 
           colClasses = "character", skip = 11)
           tableBySample <- data.frame(sample="0", chr=df$X.CHROM, ID=df$ID, X=df[,10])
           tableBySample[c(1:nrow(df)),1] <- gsub("[.]", "-", colnames(df)[10]) ########paste(strsplit(colnames(df)[10], "[.]")[[1]][1], strsplit(colnames(df)[10], "[.]")[[1]][2], strsplit(colnames(df)[10], "[.]")[[1]][3], sep="-")
            
           GATKresults <- rbind(GATKresults, tableBySample)
           }

GATKresults <- GATKresults[-which(GATKresults$SAMPLE == "" | GATKresults$SAMPLE == "SAMPLE"),] # removes none
GATKresults <- GATKresults[-which(GATKresults$ID == "" | GATKresults$ID == "NA"),] # removes 2 rows (3157, 80448) #(prior to this step,  nrow(GATKresults) = 89056. Aftter, nrow(GATKresults) =  89054)

#create new dataframe with the following columns for each sample: "sample", "chr", "start", "end", "del_1.dup_2", "copyNum", "PhredAllPtsAgree", "PhredMinOnePtAgrees" 
loc <- strsplit(GATKresults[,"ID"], "_")
mut <- strsplit(GATKresults[,"X"], ":")
cnv <- data.frame("sample"= as.character(GATKresults$sample), 
                  "chr"= sapply(loc, "[", 2), 
                  "start" = as.numeric(sapply(loc, "[", 3)), 
                  "end" = as.numeric(sapply(loc, "[", 4)), 
                  "del_1.dup_2" = sapply(mut, "[", 1), 
                  "copyNum" = sapply(mut, "[", 2),
                  "PhredAllPtsAgree" = sapply(mut, "[", 4), 
                  "PhredMinOnePtAgrees" = sapply(mut, "[", 5))

write.table(cnv, file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/GATKfor202samplesInOneTableWithQAandQS.csv")
 GATKcnv <- cnv
###################################################### XHMM

df <- read.delim(file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/XHMM/DATA.xcnv") # , colClasses = , sep=",""character"
#remove empty rows
# df <- df[-which(df$SAMPLE == ""),] # before removing empty rows (nrow(df) = 11550)

#create new dataframe with the following columns for each sample: "sample", "chr", "start", "end", "del_1.dup_2", "copyNum", "PhredAllPtsAgree", "PhredMinOnePtAgrees"
loc <- strsplit(df[,"INTERVAL"], "[:-]")

#if "DUP" -> 2, if "DEL" -> 1 for del_1.dup_2"
df$CNV[which(df$CNV == "DUP")] <- 2 
df$CNV[which(df$CNV == "DEL")] <- 1 

XHMMcnv <- data.frame("sample"= as.character(df$SAMPLE), 
                      "chr"= sapply(loc, "[", 1), 
                      "start" = as.numeric(sapply(loc, "[", 2)), 
                      "end" = as.numeric(sapply(loc, "[", 3)), 
                      "del_1.dup_2" = df$CNV, 
                      "copyNum" = "NA",
                      "PhredAllPtsAgree" = df$Q_EXACT, 
                      "PhredMinOnePtAgrees" = df$Q_SOME)
# chromosome format with "chr#"
#### XHMMcnv$chr <- paste("chr", XHMMcnv$chr, sep="")

#write.table(XHMMcnv, file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/XHMMcnv_sample_chr_start_end_del1.dup2_copyInOneTableWithQAandQS.txt", row.names=FALSE, sep=",")

######################### then see CNVanalysis/blob/main/GELCCfindOverlapInCANOES-XHMM-GATK for combining GATK and XHMM into overlaping calls.
### 12/28/21 - change rda with phenoFam and KHMMcnv and GATKcnv with Q and S to includ new updated familyPhenotypes 
#former iteration: save(XHMMcnv, GATKcnv, phenoFam, file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/XHMMcnvAndGATKcnvWithQAandQS.rda") # load(file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/XHMMcnvAndGATKcnvWithQAandQS.rda")
familyPhenotypes <- read.csv(file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/update-12.2021-phenoFam-DecodingGELCC - MatchAllInfoToSamples.csv")

# save(XHMMcnv, GATKcnv, familyPhenotypes, file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/XHMMcnvAndGATKcnvWithQAandQSwithFamilyPhenotypeUpdate12.28.21.rda")
load(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/XHMMcnvAndGATKcnvWithQAandQSwithFamilyPhenotypeUpdate12.28.21.rda")

# find overlaps between XHMM and GATK, BUT first subset to only deletions to avoid a CNV called as deletion in one is classed as duplication in the other.
# subset for deletions only: 
GATKcnv <- subset(GATKcnv, GATKcnv$del_1.dup_2 == 1) # nrow(GATKcnv) = 89054 --> 29206
XHMMcnv <- subset(XHMMcnv, XHMMcnv$del_1.dup_2 ==1) # nrow(XHMMcnv) = 11550 --> 5673


####### i need to add ENTREZID to each region using genomicRanges
# load rda from previous work, is it the chr naming convention? (this is not to be loaded for running the following. It is only for checking prior chr notation.)#load(file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/CNVsFrom3AlgsAndPhenoAndPhenoFam.2.19.2021.rda")
# at least some of the problems are coming from chromosomes in my CNV output listed only as number instead of chr#
GATKcnv$chr <- paste("chr", GATKcnv$chr, sep="")
XHMMcnv$chr <- paste("chr", XHMMcnv$chr, sep="")

XHMMcnvGranges <- makeGRangesFromDataFrame(XHMMcnv, keep.extra.columns=TRUE, seqnames.field = "chr")

GATKcnvGranges <- makeGRangesFromDataFrame(GATKcnv, keep.extra.columns=TRUE, seqnames.field = "chr")

# When run with geneRanges <- function(db, column="ENTREZID") { g <- genes(db, columns=column) # , single.strand.genes.only=TRUE
#     col <- mcols(g)[[column]]
#     genes <- granges(g)[rep(seq_along(g), elementNROWS(col))]
#     mcols(genes)[[column]] <- as.character(unlist(col))
#     genes}
#   403 genes were dropped because they have exons located on both strands
#   of the same reference sequence or on more than one reference sequence,
#   so cannot be represented by a single genomic range.
#   Use 'single.strand.genes.only=FALSE' to get all the genes in a
#   GRangesList object

####################################################################################################

gns = geneRanges(Homo.sapiens, column="SYMBOL")
trnscrpts = transcriptRanges(Homo.sapiens, column="SYMBOL")
coding <- cdsRanges(Homo.sapiens, column="SYMBOL")
EID <- geneRanges(Homo.sapiens)

# splitByOverlap genes, transcripts, CDS by GATKcnvGranges
gns_symInCnv = splitByOverlap(gns, GATKcnvGranges, "SYMBOL")
trnscrpts_symInCnv = splitByOverlap(trnscrpts, GATKcnvGranges, "SYMBOL")
coding_symInCnv = splitByOverlap(coding, GATKcnvGranges, "SYMBOL")
entrez_symInCnv = splitByOverlap(EID, GATKcnvGranges, "ENTREZID")

GATKcnv$gene <- NA
GATKcnv$transcript <- NA
GATKcnv$CDS <- NA
GATKcnv$Entrez <- NA

# GATK - loop through each CNV listed in each table from each algorithm
for(i in 1:nrow(GATKcnv)){
cat("GATKcnv #", i, " covers ", paste(gns_symInCnv[[i]][!is.na(gns_symInCnv[[i]])], collapse=", "), "\n")
GATKcnv$gene[i] <-  paste(gns_symInCnv[[i]][!is.na(gns_symInCnv[[i]])], collapse=", ")
GATKcnv$transcript[i] <- paste(trnscrpts_symInCnv[[i]][!is.na(trnscrpts_symInCnv[[i]])], collapse=", ")
GATKcnv$CDS[i] <- paste(coding_symInCnv[[i]][!is.na(coding_symInCnv[[i]])], collapse=", ")
GATKcnv$Entrez[i] <-paste(entrez_symInCnv[[i]][!is.na(entrez_symInCnv[[i]])], collapse=", ")
           }

# write.table(GATKcnv, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/GATKcnv_delsONLY.9.30.21.csv", row.names=FALSE, sep=",") #quote=c(1:3)???
# GATKcnv <- read.csv(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/GATKcnv_delsONLY.9.30.21.csv")
# splitByOverlap genes, transcripts, CDS by XHMMcnvGranges
gns_symInCnv = splitByOverlap(gns, XHMMcnvGranges, "SYMBOL")
trnscrpts_symInCnv = splitByOverlap(trnscrpts, XHMMcnvGranges, "SYMBOL")
coding_symInCnv = splitByOverlap(coding, XHMMcnvGranges, "SYMBOL")
entrez_symInCnv = splitByOverlap(EID, XHMMcnvGranges, "ENTREZID")

XHMMcnv$gene <- NA
XHMMcnv$transcript <- NA
XHMMcnv$CDS <- NA
XHMMcnv$Entrez <- NA

# XHMM - loop through each CNV listed in each table from each algorithm
for(i in 1:nrow(XHMMcnv)){
cat("XHMMcnv #", i, " covers ", paste(gns_symInCnv[[i]][!is.na(gns_symInCnv[[i]])], collapse=", "), "\n")
XHMMcnv$gene[i] <- paste(gns_symInCnv[[i]][!is.na(gns_symInCnv[[i]])], collapse=", ")
XHMMcnv$transcript[i] <- paste(trnscrpts_symInCnv[[i]][!is.na(trnscrpts_symInCnv[[i]])], collapse=", ")
XHMMcnv$CDS[i] <- paste(coding_symInCnv[[i]][!is.na(coding_symInCnv[[i]])], collapse=", ")
XHMMcnv$Entrez[i] <-paste(entrez_symInCnv[[i]][!is.na(entrez_symInCnv[[i]])], collapse=", ")
           }
# write.table(XHMMcnv, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/XHMMcnv_delsONLY.9.30.21.csv", row.names=FALSE, sep=",") #quote=c(1:3)???

######################################################################################
## note to self: 10/14/21 - i could redo overlap between XHMM and GATK and include the intersection/union to include as a column to interpret the degreee of overlap

#add copyNum to data.frame of overlaps  
for(i in unique(GATKcnv$sample)){                      #i = GATKcnv$sample[1]
A <- FALSE
B <- FALSE

A <- makeGRangesFromDataFrame(subset(GATKcnv, GATKcnv$sample == i), keep.extra.columns=TRUE) 
if(any(XHMMcnv$sample == i)){
B <- makeGRangesFromDataFrame(subset(XHMMcnv, XHMMcnv$sample == i), keep.extra.columns=TRUE)

    ABlaps <- findOverlaps(A, B)
    ABsect <- pintersect(A[queryHits(ABlaps)], B[subjectHits(ABlaps)])
   
   ##################################### GATK vs. XHMM CALLS TO SUBSET BY SAMPLE/INDIVIDUAL#####################################
    GATKandXHMM <- data.frame(
                sample = A$sample[queryHits(ABlaps)],
                chr = as.data.frame(A)$seqnames[queryHits(ABlaps)],
                GATKstart = as.data.frame(A)$start[queryHits(ABlaps)],
                GATKend = as.data.frame(A)$end[queryHits(ABlaps)],
                XHMMstart = as.data.frame(B)$start[subjectHits(ABlaps)],
                XHMMend = as.data.frame(B)$end[subjectHits(ABlaps)],
                query=queryHits(ABlaps), 
                subject=subjectHits(ABlaps),
                olap_width=width(ABsect), 
                query_width=width(A)[queryHits(ABlaps)],
                GATKcall.copyNum = as.data.frame(A)$copyNum[queryHits(ABlaps)],
                GATKgene=A$gene[queryHits(ABlaps)],
                XHMMgene = B$gene[subjectHits(ABlaps)],
                GATKPhred = A$PhredMinOnePtAgrees[queryHits(ABlaps)],
                XHMMPhred = B$PhredMinOnePtAgrees[subjectHits(ABlaps)],
                #add PhredMinOnePtAgrees for both. add CDS or transcipt or EID? for both Algs?
                # del/dup is not helpful as these are all deletions
                # GATKcall.del_1.dup_2 = as.data.frame(A)$del_1.dup_2[queryHits(ABlaps)],
                # XHMMcall.del_1.dup_2 = as.data.frame(B)$del_1.dup_2[subjecHits(ABlaps)],
                
                # GATKcds = A$CDS[queryHits(ABlaps)],
                #  XHMMcds = B$CDS[subjectHits(ABlaps)],
                
                # GATKtranscipt = A$transcript[queryHits(ABlaps)],
                # XHMMtranscipt = B$transcript[subjectHits(ABlaps)],
                
                GATKentrez = A$Entrez[queryHits(ABlaps)],
                XHMMentrez = B$Entrez[subjectHits(ABlaps)]
                )
                
    write.table(GATKandXHMM, file=paste("C:/Users/4wald/OneDrive - LSUHSC/GELCC/callsInCommonGATKandXHMMpluScopyNum/9.30.21.GATKandXHMM.", i, ".csv", sep=""), row.names=FALSE, sep=",") #quote=c(1:3)???
    } else {
        cat("no.olaps in ", i)
        GATKandXHMM <- data.frame(sample = i,
                chr = "no.olaps",
                GATKstart = "no.olaps",
                GATKend = "no.olaps",
                XHMMstart = "no.olaps",
                XHMMend = "no.olaps",
                query= "no.olaps", 
                subject="no.olaps",
                olap_width="no.olaps", 
                query_width="no.olaps",
                GATKcall.copyNum = "no.olaps",
                # del/dup is not helpful as these are all deletions
                # GATKcall.del_1.dup_2 = as.data.frame(A)$del_1.dup_2[queryHits(ABlaps)],
                # XHMMcall.del_1.dup_2 = as.data.frame(B)$del_1.dup_2[subjecHits(ABlaps)],
                GATKgene="no.olaps",
                XHMMgene = "no.olaps",
                GATKPhred = "no.olaps",
                XHMMPhred = "no.olaps",
                
                GATKentrez = "no.olaps",
                XHMMentrez = "no.olaps"

                      )
        write.table(GATKandXHMM, file=paste("C:/Users/4wald/OneDrive - LSUHSC/GELCC/callsInCommonGATKandXHMMpluScopyNum/9.30.21.GATKandXHMM.", i, ".csv", sep=""), row.names=FALSE, sep=",")
                }

} # end of loop

##create new data.frame with overlapping cnvs + copyNum

overlappingCNVs <- matrix(nrow=0, ncol=17)
overlappingCNVs <- as.data.frame(overlappingCNVs)
colnames(overlappingCNVs) <- c("sample", "chr", "GATKstart", "GATKend", "XHMMstart", "XHMMend", 
                                "query", "subject", "olap_width", "query_width", 
                                "GATKcall.copyNum", "GATKgene", "XHMMgene", "GATKPhred", "XHMMPhred",
                                "GATKentrez", "XHMMentrez")
i=0
for(i in unique(GATKcnv$sample)){                      #i = GATKcnv$sample[1]
  
  GATKandXHMM <- read.csv(file = paste("C:/Users/4wald/OneDrive - LSUHSC/GELCC/callsInCommonGATKandXHMMpluScopyNum/9.30.21.GATKandXHMM.", i, ".csv", sep=""))
  cat(GATKandXHMM[1,1], "\n")
  overlappingCNVs <- rbind(overlappingCNVs, GATKandXHMM)
}

write.table(overlappingCNVs, file=paste("C:/Users/4wald/OneDrive - LSUHSC/GELCC/9.30.21.compositeOfCNVsCalledByGATKandXHMM", ".csv", sep=""), row.names=FALSE, sep=",")
# overlappingCNVs <- read.csv(file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/9.30.21.compositeOfCNVsCalledByGATKandXHMM.csv")

#  replacing with new familyPhenotypes: prior iteration with old phenoFam: # save(overlappingCNVs, phenoFam, XHMMcnv, GATKcnv, file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/overlappingCNVsBothAlgsPhenoFam.9.29.21.rda")  
# save(overlappingCNVs, familyPhenotypes, XHMMcnv, GATKcnv, file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/overlappingCNVsBothAlgsPhenoFam.12.28.21.rda") # from load(file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/overlappingCNVsBothAlgsPhenoFam.9.29.21.rda")
# load(file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/overlappingCNVsBothAlgsPhenoFam.12.28.21.rda")

####### characterize differences in GATK and XHMM calls
# length(which(overlappingCNVs$GATKgene != overlappingCNVs$XHMMgene)) # = 2732 (39% aren't identical)
# nrow(overlappingCNVs) # = 7052
# overlappingCNVs[which(overlappingCNVs$GATKgene != overlappingCNVs$XHMMgene)[10:20],c(3, 4, 5, 6, 7, 8, 12, 13, 14, 15)]
# From examining the overlap between calls and address redundannt calls I think it best to find the first instance of a gene overlapping a deletion and remove subsequent calls of a deletion covering that same gene
# it appears that many of these redundant calls also have a low GATKPhred score
# if XHMM genes match previous, then take the one of the two with the higher GATK Phred Score
# change structure to go by sample, id anyCNVs with the same genes and include only the one with the highest Phred score

keep <- vector()
for(i in unique(overlappingCNVs$sample)) { # i = unique(overlappingCNVs$sample)[42]
    for(j in which(overlappingCNVs$sample == i)){ # j = which(overlappingCNVs$sample == i)[5]
        w <- which(overlappingCNVs$XHMMgene[j] == overlappingCNVs$XHMMgene[which(overlappingCNVs$sample == i)])
            if(length(w) < 2){ keep =  append(keep, j) 
                } else { 
                phScores <- overlappingCNVs$GATKPhred[which(overlappingCNVs$sample == i)][w]
                if(overlappingCNVs$GATKPhred[j] == max(as.numeric(phScores))){
                       if(j %in% keep == FALSE){
                            keep =  append(keep, j)
                            } # if j is not already in keep
                        } # if j highest Phred
                   } # else w > 1     
            } # for j 
      } # for i

######################################################################################
###########################The old way of removing redundant calls ####################################
######################################################################################
#remove <- vector()
#for (i in 2:nrow(overlappingCNVs)){ # i = 56
#    if (strsplit(overlappingCNVs$XHMMgene[i], split = ", ") %in% strsplit(overlappingCNVs$XHMMgene[i-1], split = ", ")){
#        k = c(i-1,i)[which(as.numeric(overlappingCNVs[c(i-1,i),"GATKPhred"])==min(as.numeric(overlappingCNVs[c(i-1,i),"GATKPhred"])))[1]]
#        m = c(i-1,i)[which(as.numeric(overlappingCNVs[c(i-1,i),"GATKPhred"])==max(as.numeric(overlappingCNVs[c(i-1,i),"GATKPhred"])))[1]]
#        overlappingCNVs <- overlappingCNVs[-k,]
#        remove <- append(remove, k)
#        cat("deleting row ", k, " GATKPhred = ", overlappingCNVs$GATKPhred[k], " is less than ", overlappingCNVs$GATKPhred[m], '\n')
#        } # if same genes as row i-1
#    } #nrow
#nrow(overlappingCNVs) = 7052 --> 3871
# overlappingCNVs[,] # overlappingCNVs[which(overlappingCNVs$sample =="H_NK-127GELCC001-127001"),]
# strsplit(overlappingCNVs$GATKgene[6844], split = ", ") %in% strsplit(overlappingCNVs$GATKgene[6845], split = ", ")
# overlappingCNVs$GATKgene[6843] %in% overlappingCNVs$GATKgene[6844]
######################################################################################
######################################################################################
######################################################################################

# length(keep) # = 3636
overlappingCNVsPostRemoved <- overlappingCNVs[keep,]

# replacing old version of phenoFam saved in this file save(overlappingCNVs, overlappingCNVsPostRemoved, GATKcnv, XHMMcnv, phenoFam, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/9.30.21.callsPhenoRemovedRedundant.rda")
# save(overlappingCNVs, overlappingCNVsPostRemoved, GATKcnv, XHMMcnv, familyPhenotypes, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/12.28.21.callsPhenoRemovedRedundant.rda") # saved with new familyPhenotypes and files from: load(file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/9.30.21.callsPhenoRemovedRedundant.rda")
# load(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/12.28.21.callsPhenoRemovedRedundant.rda")

#see what we have here for genes
genesBothCallersAllDeletions <- unlist(strsplit(overlappingCNVsPostRemoved$XHMMgene, split = ", ")) 

# length(unique(genesBothCallersAllDeletions)) = now 879, first time around (week of 9/21) it was 580

#unique(familyPhenotypes$CID) that need checked for marriedins: "103" "105" "25"  "11"  "127" "135" "26"  "31"  "33" "34" "42"  "44" "59"  "62"  "69" "90"  "94" "New"
# check against construction of pedigrees produced here: https://github.com/johnbwaldron/CNVanalysis/edit/main/makePedigrees
# obtain list of genes affected by deletions in married-ins and remove those genes from the list of the families because these genes identified in married-ins are unlikely to contribute to pathogenesis

# marriedInSampleName <- phenoFam[phenoFam$CID == 12 & phenoFam$CIND == 44 | phenoFam$CID == 12 & phenoFam$CIND == 29 |
#                       phenoFam$CID == 35 & phenoFam$CIND == 29| 
#                       phenoFam$CID == 47 & phenoFam$CIND == 16|
#                       phenoFam$CID == 102 & phenoFam$CIND == 346|
#                       phenoFam$CID == 131 &  phenoFam$CIND == 125 |
#                       phenoFam$CID == 103 &  phenoFam$CIND == 117 |
#                       phenoFam$CID == 52 & phenoFam$CIND == 4| phenoFam$CID == 52 & phenoFam$CIND == 13|
#                       phenoFam$CID == 88 & phenoFam$CIND == 13| phenoFam$CID == 88 & phenoFam$CIND == 52,1]
                       
###!!! 9.30.21 I am going to leave this for now, but this is where I need to account for ALL married-in CINDs
# load data from database to examine and identify 
# db <- read.csv(file= "C:/Users/4wald/OneDrive - LSUHSC/GELCC/Demographics - Demographics.csv")
## spouses <- subset(db, db$CF == 0)

# up to date list of married in sample names from creation all all pedigrees 3/14/22 (above (9/30/21) is old/defunct):
marriedInSampleName <- familyPhenotypes[familyPhenotypes$CID == 12 & familyPhenotypes$CIND == 44 | familyPhenotypes$CID == 12 & familyPhenotypes$CIND == 29 |
                       familyPhenotypes$CID == 103 & familyPhenotypes$CIND == 117|
                       familyPhenotypes$CID == 25 & familyPhenotypes$CIND == 3|
                       familyPhenotypes$CID == 26 & familyPhenotypes$CIND == 20|
                       familyPhenotypes$CID == 31 & familyPhenotypes$CIND == 5|
                       familyPhenotypes$CID == 33 & familyPhenotypes$CIND == 2|
                       familyPhenotypes$CID == 34 & familyPhenotypes$CIND == 12|
                       familyPhenotypes$CID == 69 & familyPhenotypes$CIND == 112| familyPhenotypes$CID == 69 & familyPhenotypes$CIND == 102 |
                       familyPhenotypes$CID == 90 & familyPhenotypes$CIND == 55 |
                       familyPhenotypes$CID == 135 & familyPhenotypes$CIND == 122 |
                       familyPhenotypes$CID == 35 & familyPhenotypes$CIND == 29| 
                       familyPhenotypes$CID == 47 & familyPhenotypes$CIND == 16|
                       familyPhenotypes$CID == 102 & familyPhenotypes$CIND == 346|
                       familyPhenotypes$CID == 131 &  familyPhenotypes$CIND == 125 |
                       familyPhenotypes$CID == 52 & familyPhenotypes$CIND == 4| familyPhenotypes$CID == 52 & familyPhenotypes$CIND == 13|
                       familyPhenotypes$CID == 88 & familyPhenotypes$CIND == 13| familyPhenotypes$CID == 88 & familyPhenotypes$CIND == 52,1]
 

delCallsLCfamilies <- overlappingCNVsPostRemoved[-which(overlappingCNVsPostRemoved$sample %in% marriedInSampleName),]
delCallsMarriedIn <- overlappingCNVsPostRemoved[which(overlappingCNVsPostRemoved$sample %in% marriedInSampleName),]


delCallsLCfamiliesgeneIDs <- unlist(strsplit(delCallsLCfamilies$XHMMgene, split = ", "))  # length(unique(delCallsLCfamiliesgeneIDs)) = now (9/30/21) 813, prior to 9/30/21 it was 566

delCallsMARRIEDINgeneIDs <- unlist(strsplit(delCallsMarriedIn$XHMMgene, split = ", "))

delCallsLCfamiliesgeneIDs %in% unique(delCallsMARRIEDINgeneIDs)

genesLCfamilyONLY <- delCallsLCfamiliesgeneIDs[-which(delCallsLCfamiliesgeneIDs %in% delCallsMARRIEDINgeneIDs)] 

# length(delCallsLCfamiliesgeneIDs %in% delCallsMARRIEDINgeneIDs) = 5771, length(delCallsLCfamiliesgeneIDs) = 7061

# save(delCallsLCfamilies, file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/10.18.21.delCallsLCfamilies.rda")

save(genesLCfamilyONLY, delCallsLCfamilies, delCallsMarriedIn, familyPhenotypes, overlappingCNVs, overlappingCNVsPostRemoved, pheno, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/03.14.22.delCallsLCfamilies.rda")

#####################################################################################################################
# use gnomAD deletions and AF to remove common deletions
gnomAD <- read.delim(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/hg19_gnomadSVs.txt")

# limit gnomAD input to deletions
gnomADdels <- gnomAD[grep("DEL", gnomAD$sv_type),] # ### length(grep("DEL", gnomAD$sv_type)) = 169635

# could use load overlappingCNVs
# load(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/10.3.21.upToAllDataOrganizedByGene.rda")
# filter step to remove those with high AF using "delCallsLCfamilies" which excludes: 
# married-in CINDs, multiple GATK calls for a single XHMM, calls not made by both XHMM and GATK, anything but deletions
# load(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/delCallsLCfamilies.rda")
# delCallsLCfamilies$GATKstart[which(is.na(as.numeric(delCallsLCfamilies$GATKstart)))]

myDels <- delCallsLCfamilies


# need to make chr numbers only
l <- strsplit(myDels$chr, "chr") 
numb <- sapply(l, "[", 2)
myDels$chr <- numb

# one sample that had no overlaps between XHMM and GATK cannot be made into GRanges because of nonnumeric values. change that. myDeletions[which(!is.numeric(myDeletions$GATKstart)),] <- as.numeric(myDeletions[which(!is.numeric(myDeletions$GATKstart)),3])
myDels[grep("no.olaps", myDels[,"GATKstart"]), c("chr","GATKstart", "GATKend")] <- 0 # myDels[4840,]
# change column name of XHMMstart and XHMMend to retain them, but not to pass them to GRanges as start and end values
colnames(myDels)[5:6] <- c("XHMM.s", "XHMM.e")

A <- makeGRangesFromDataFrame(myDels, keep.extra.columns=TRUE) 

# need to have seqnames for GRange object 3 GRanges does not recognize "X.chrom"
colnames(gnomADdels)[1] <- "chr"

B <- makeGRangesFromDataFrame(gnomADdels, keep.extra.columns=TRUE)

#### percent overlap between A and B defined by the ratio of the intersection of A and B to the union of A and B.

    ABlaps <- findOverlaps(A, B)
    ABsect <- pintersect(A[queryHits(ABlaps)], B[subjectHits(ABlaps)])
    ABunion <- punion(A[queryHits(ABlaps)], B[subjectHits(ABlaps)])
  
    #ABpairs <- findOverlapPairs(A, B)
    #pairs <- as.data.frame(ABpairs)
    #ABpairSect <- pintersect(ABpairs)
    #ABpairUnion <- punion
    
   B$allele_frequency[subjectHits(ABlaps)]
##########################################################################
    gnomADoverlap <- data.frame(
                sample = A$sample[queryHits(ABlaps)],
                chr = as.data.frame(A)$seqnames[queryHits(ABlaps)],
                GATKstart = as.data.frame(A)$start[queryHits(ABlaps)],
                GATKend = as.data.frame(A)$end[queryHits(ABlaps)],
                gnomADstart = as.data.frame(B)$start[subjectHits(ABlaps)],
                gnomADend = as.data.frame(B)$end[subjectHits(ABlaps)],
                query=queryHits(ABlaps), 
                subject=subjectHits(ABlaps),
                intersection_width=width(ABsect), 
                union_width=width(ABunion),
                pctOverlap = round(width(ABsect)/width(ABunion), 2),
                allele_frequency = as.data.frame(B)$allele_frequency[subjectHits(ABlaps)]
                                )

# now subset gnomADoverlap to only those with > 75% intersection/union
G75pctGnomAD <- gnomADoverlap[which(gnomADoverlap$pctOverlap > .75),]

#Add this information back to the overlappingCNVs
    # need chr format to match between the two 
    l <- strsplit(overlappingCNVs$chr, "chr") 
    numb <- sapply(l, "[", 2)
    overlappingCNVs$chr <- numb
########################################################################## Failed effort to merge the tables ##########################################################################
# library(data.table)
# keys <- c("sample", "chr", "GATKstart", "GATKend")
# toverlappingCNVs <- data.table(overlappingCNVs, key=keys)
# tgnomADoverlap <- data.table(gnomADoverlap[,-which(colnames(G75pctGnomAD) %in% c("query", "subject"))], key=keys)
# tgnomADoverlap$GATKstart <- as.character(tgnomADoverlap$GATKstart)
# tgnomADoverlap$GATKend <- as.character(tgnomADoverlap$GATKend)
# toverlappingCNVs <- toverlappingCNVs[tgnomADoverlap]
# toverlappingCNVs[tgnomADoverlap, by=.EACHI]

# overlappingCNVsWgnomAD <- merge(overlappingCNVs, gnomADoverlap[,-which(colnames(gnomADoverlap) %in% c("query", "subject"))], all.x = TRUE, no.dups = TRUE)
# overlappingCNVsWgnomAD$pctOverlap
####################################################################################################################################################

# created new data table to fill in allele frequencies and pct overlap values for CNV/dels with at least 75% of intersection/union with gnomAD calls 
# x <- c()
#overlappingCNVsWgnomAD <- cbind(myDels, data.frame(gnomADpctOverlap = NA, allele_frequency = NA, gnomADpctOverlap2 = NA, allele_frequency2 = NA))
#   for(i in 1:nrow(overlappingCNVsWgnomAD)){ # i = 10
#        for(j in 1:nrow(G75pctGnomAD)){ # j = 4 # for(j in 1:nrow(gnomADoverlap)){
#            if(overlappingCNVsWgnomAD$sample[i] == G75pctGnomAD$sample[j] &&
#               overlappingCNVsWgnomAD$chr[i] == G75pctGnomAD$chr[j] &&
#               overlappingCNVsWgnomAD$GATKstart[i] == G75pctGnomAD$GATKstart[j] &&
#               overlappingCNVsWgnomAD$GATKend[i] == G75pctGnomAD$GATKend[j]) {
#                    if(is.na(overlappingCNVsWgnomAD$gnomADpctOverlap[i]))overlappingCNVsWgnomAD$gnomADpctOverlap[i] <- G75pctGnomAD$pctOverlap[j] else {
#                        overlappingCNVsWgnomAD$gnomADpctOverlap2[i] <- G75pctGnomAD$pctOverlap[j]
#                        cat("found an overwrite at row", i, "\n")
#                        x <- c(x, i)
#                        } # else (not na)
#                    if(is.na(overlappingCNVsWgnomAD$allele_frequency[i])) overlappingCNVsWgnomAD$allele_frequency[i] <- G75pctGnomAD$allele_frequency[j] else overlappingCNVsWgnomAD$allele_frequency2[i] <- G75pctGnomAD$allele_frequency[j]
                    # cat("G75pctGnomAD row #", j, "\n")
#                    } # if matches [,1:4]
#            } # for j (rows in G75pctGnomAD)
#      } # for i (rows in overlappingCNVsWgnomAD
              
                       
removedCommonVariants <- overlappingCNVsWgnomAD[which(overlappingCNVsWgnomAD$AF1 > 0.05),c(1,2)]
##############################################################################
# because there are so many with small amounts of overlap that everything gets overwritten
# So i need to order the pctoverlap for a given query to lowest to highest, so highest values overwrite all at the end.

x <- c()
overlappingCNVsWgnomAD <- cbind(myDels, data.frame(gnomADpctOverlap = NA, allele_frequency = NA, gnomADpctOverlap2 = NA, allele_frequency2 = NA))

for(i in 1:nrow(overlappingCNVsWgnomAD)){ # i = 10
        for(j in 1:nrow(gnomADoverlap)){ # j = 3 # 
             if(overlappingCNVsWgnomAD$sample[i] == gnomADoverlap$sample[j] &&
               overlappingCNVsWgnomAD$chr[i] == gnomADoverlap$chr[j] &&
               overlappingCNVsWgnomAD$GATKstart[i] == gnomADoverlap$GATKstart[j] &&
               overlappingCNVsWgnomAD$GATKend[i] == gnomADoverlap$GATKend[j]) {   
                    valByQuery <- gnomADoverlap[which(gnomADoverlap$query==gnomADoverlap$query[j]), c("pctOverlap", "allele_frequency")]
                    topTwoPct <- valByQuery[order(valByQuery$pctOverlap, decreasing = TRUE),]
                        overlappingCNVsWgnomAD$gnomADpctOverlap[i] <- topTwoPct$pctOverlap[1] 
                        overlappingCNVsWgnomAD$gnomADpctOverlap2[i] <- topTwoPct$pctOverlap[2]
                        overlappingCNVsWgnomAD$allele_frequency[i] <- topTwoPct$allele_frequency[1]
                        overlappingCNVsWgnomAD$allele_frequency2[i] <- topTwoPct$allele_frequency[2]
                        
                        x <- c(x, i)
                } # if gnomADoverlap row matches everything in overlappingCVNsWgnomAD          
                   
            } # for j (rows in gnomADoverlap)
      } # for i (rows in overlappingCNVsWgnomAD)   
# percent of CNVs called only in lung cancer families and identified by both algorithms found in gnomAD:
length(which(!is.na(overlappingCNVsWgnomAD$gnomADpctOverlap)))/length(overlappingCNVsWgnomAD$gnomADpctOverlap)

# 73.4% of deletions called by both algorithms, only found in LC families overalp at least somewhat with gnomAD variants.
length(which(overlappingCNVsWgnomAD$gnomADpctOverlap >.74))/length(overlappingCNVsWgnomAD$gnomADpctOverlap)

# 10.05% of all deletions called by both algorithms, only found in LC families have > 75% overlap with gnomAD variants
# save (overlappingCNVsWgnomAD, file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/overlappingCNVsWgnomAD.10.13.21.rda")
# load(file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/overlappingCNVsWgnomAD.10.13.21.rda")

save (overlappingCNVsWgnomAD, genesLCfamilyONLY, delCallsLCfamilies, delCallsMarriedIn, 
familyPhenotypes, overlappingCNVs, overlappingCNVsPostRemoved, pheno, file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/overlappingCNVsWgnomAD.03.15.22.rda")

# subset to those calls with AF < 0.05
delBothCallsLCfamiliesUncommon <- overlappingCNVsWgnomAD[-which(overlappingCNVsWgnomAD$allele_frequency > 0.05),]
################################ delBothCallsLCfamiliesUncommon  <- subset(overlappingCNVsWgnomAD, is.na(overlappingCNVsWgnomAD$allele_frequency) | overlappingCNVsWgnomAD$allele_frequency < 0.05)


##############################################################################   
#####################################################################################################################
# remove CNVs based on the degree of overlap with married-ins CNVs (rather than just removing by gene identifier) just like was done for CNVs in gnomAD
load(file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/overlappingCNVsWgnomAD.03.15.22.rda")

# married in calls: delCallsMarriedIn
# calls in LC famliies over with noted over lap of CNVs from gnomAD: overlappingCNVsWgnomAD

# need to make chr numbers only
l <- strsplit(delCallsMarriedIn$chr, "chr") 
numb <- sapply(l, "[", 2)
delCallsMarriedIn$chr <- numb

# change column name of XHMMstart and XHMMend to retain them, but not to pass them to GRanges as start and end values
colnames(delCallsMarriedIn)[5:6] <- c("XHMM.s", "XHMM.e")

A <- makeGRangesFromDataFrame(overlappingCNVsWgnomAD, keep.extra.columns=TRUE) 

B <- makeGRangesFromDataFrame(delCallsMarriedIn, keep.extra.columns=TRUE)

#### percent overlap between A and B defined by the ratio of the intersection of A and B to the union of A and B.

    ABlaps <- findOverlaps(A, B)
    ABsect <- pintersect(A[queryHits(ABlaps)], B[subjectHits(ABlaps)])
    ABunion <- punion(A[queryHits(ABlaps)], B[subjectHits(ABlaps)])
  

##########################################################################
    marriedInOverlap <- data.frame(
                sample = A$sample[queryHits(ABlaps)],
                chr = as.data.frame(A)$seqnames[queryHits(ABlaps)],
                GATKstart = as.data.frame(A)$start[queryHits(ABlaps)],
                GATKend = as.data.frame(A)$end[queryHits(ABlaps)],
                marriedInSample = B$sample[subjectHits(ABlaps)],
                marriedInStart = as.data.frame(B)$start[subjectHits(ABlaps)],
                marriedInEnd = as.data.frame(B)$end[subjectHits(ABlaps)],
                query = queryHits(ABlaps), 
                subject = subjectHits(ABlaps),
                intersection_width = width(ABsect), 
                union_width = width(ABunion),
                pctOverlap = round(width(ABsect)/width(ABunion), 2)
                                                )
#####################################################################################################################
# add percent overlap with married ins to the data.frame of only LC family members plus gnomAD overlap and Allele frequency
x <- c()
overlappingCNVsWgnomADandMMarriedINs <- cbind(overlappingCNVsWgnomAD, data.frame(marriedInpctOverlap = NA, marriedInpctOverlap2 = NA, marriedInpctOverlap3 = NA))

for(i in 1:nrow(overlappingCNVsWgnomADandMMarriedINs)){ # i = 10
        for(j in 1:nrow(marriedInOverlap)){ # j = 3 # 
             if(overlappingCNVsWgnomADandMMarriedINs$sample[i] == marriedInOverlap$sample[j] &&
               overlappingCNVsWgnomADandMMarriedINs$chr[i] == marriedInOverlap$chr[j] &&
               overlappingCNVsWgnomADandMMarriedINs$GATKstart[i] == marriedInOverlap$GATKstart[j] &&
               overlappingCNVsWgnomADandMMarriedINs$GATKend[i] == marriedInOverlap$GATKend[j]) {   
                    valByQuery <- marriedInOverlap[which(marriedInOverlap$query==marriedInOverlap$query[j]), c("pctOverlap")]
                    topThreePct <- valByQuery[order(valByQuery, decreasing = TRUE)]
                        overlappingCNVsWgnomADandMMarriedINs$marriedInpctOverlap[i] <- topThreePct[1] 
                        overlappingCNVsWgnomADandMMarriedINs$marriedInpctOverlap2[i] <- topThreePct[2]
                        overlappingCNVsWgnomADandMMarriedINs$marriedInpctOverlap3[i] <- topThreePct[3]                                        
                        x <- c(x, i)
                } # if marriedInOverlap row matches everything in overlappingCNVsWgnomADandMMarriedINs          
                   
            } # for j (rows in gnomADoverlap)
      } # for i (rows in overlappingCNVsWgnomAD)   


#####################################################################################################################
# carry-out comparison of overlap with calls in married ins and with gnomAD calls to the "overlappingCNVs" prior to 
# removing multiple GATK calls overlaping with XHMM calls # i am doing this because identifying overlap with gnomad and married ins, etc is likely influenced by which calls remain. 
#  load(file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/overlappingCNVsWgnomAD.03.15.22.rda")
olapCNVs <- overlappingCNVs[which(as.numeric(overlappingCNVs$GATKPhred)>19), c(1:15)]
# nrow(olapCNVs) vs nrow(overlappingCNVs)
marriedInSampleName <- familyPhenotypes[familyPhenotypes$CID == 12 & familyPhenotypes$CIND == 44 | familyPhenotypes$CID == 12 & familyPhenotypes$CIND == 29 |
                       familyPhenotypes$CID == 103 & familyPhenotypes$CIND == 117|
                       familyPhenotypes$CID == 25 & familyPhenotypes$CIND == 3|
                       familyPhenotypes$CID == 26 & familyPhenotypes$CIND == 20|
                       familyPhenotypes$CID == 31 & familyPhenotypes$CIND == 5|
                       familyPhenotypes$CID == 33 & familyPhenotypes$CIND == 2|
                       familyPhenotypes$CID == 34 & familyPhenotypes$CIND == 12|
                       familyPhenotypes$CID == 69 & familyPhenotypes$CIND == 112| familyPhenotypes$CID == 69 & familyPhenotypes$CIND == 102 |
                       familyPhenotypes$CID == 90 & familyPhenotypes$CIND == 55 |
                       familyPhenotypes$CID == 135 & familyPhenotypes$CIND == 122 |
                       familyPhenotypes$CID == 35 & familyPhenotypes$CIND == 29| 
                       familyPhenotypes$CID == 47 & familyPhenotypes$CIND == 16|
                       familyPhenotypes$CID == 102 & familyPhenotypes$CIND == 346|
                       familyPhenotypes$CID == 131 &  familyPhenotypes$CIND == 125 |
                       familyPhenotypes$CID == 52 & familyPhenotypes$CIND == 4| familyPhenotypes$CID == 52 & familyPhenotypes$CIND == 13|
                       familyPhenotypes$CID == 88 & familyPhenotypes$CIND == 13| familyPhenotypes$CID == 88 & familyPhenotypes$CIND == 52,1]

delCallsLCfamilies <- olapCNVs[-which(olapCNVs$sample %in% marriedInSampleName),]
delCallsMarriedIn <- olapCNVs[which(olapCNVs$sample %in% marriedInSampleName),]

# save(delCallsLCfamilies, delCallsMarriedIn, familyPhenotypes, olapCNVs, pheno, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/03.15.22.allDelCallsLCfamilies.rda")
####
##### use gnomAD deletions and AF to remove common deletions
gnomAD <- read.delim(file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/hg19_gnomadSVs.txt")
# limit gnomAD input to deletions
gnomADdels <- gnomAD[grep("DEL", gnomAD$sv_type),] # ### length(grep("DEL", gnomAD$sv_type)) = 169635

myDels <- delCallsLCfamilies
# need to make chr numbers only
l <- strsplit(myDels$chr, "chr") 
numb <- sapply(l, "[", 2)
myDels$chr <- numb

GATKranges <- makeGRangesFromDataFrame(myDels[,c(1:4,7:15)], keep.extra.columns=TRUE) 
XHMMranges <- makeGRangesFromDataFrame(myDels[,c(1:2,5:15)], keep.extra.columns=TRUE) 

# need to have seqnames for GRange object 3 GRanges does not recognize "X.chrom"
colnames(gnomADdels)[1] <- "chr"
gnomADranges <- makeGRangesFromDataFrame(gnomADdels, keep.extra.columns=TRUE)
    
    #overlaps
    GATKxgnomADlaps <- findOverlaps(GATKranges, gnomADranges)
    XHMMxgnomADlaps <- findOverlaps(XHMMranges, gnomADranges)
   #intersection 
   GATKxgnomADsect <- pintersect(GATKranges[queryHits(GATKxgnomADlaps)], gnomADranges[subjectHits(GATKxgnomADlaps)])
   XHMMxgnomADsect <- pintersect(XHMMranges[queryHits(XHMMxgnomADlaps)], gnomADranges[subjectHits(XHMMxgnomADlaps)])
   #union 
    GATKxgnomADunion <- punion(GATKranges[queryHits(GATKxgnomADlaps)], gnomADranges[subjectHits(GATKxgnomADlaps)])
    XHMMxgnomADunion <- punion(XHMMranges[queryHits(XHMMxgnomADlaps)], gnomADranges[subjectHits(XHMMxgnomADlaps)])

XHMMgnomADoverlap <- data.frame(
                sample = XHMMranges$sample[queryHits(XHMMxgnomADlaps)],
                chr = as.data.frame(XHMMranges)$seqnames[queryHits(XHMMxgnomADlaps)],
                start = as.data.frame(XHMMranges)$start[queryHits(XHMMxgnomADlaps)],
                end = as.data.frame(XHMMranges)$end[queryHits(XHMMxgnomADlaps)],
                query=queryHits(XHMMxgnomADlaps), 
                subject=subjectHits(XHMMxgnomADlaps),
                XHMMxgnomAD_sect_width=width(XHMMxgnomADsect),
                XHMMxgnomAD_union_width=width(XHMMxgnomADunion),
                pctOverlap = round(width(XHMMxgnomADsect)/width(XHMMxgnomADunion), 2),
                allele_frequency = as.data.frame(gnomADranges)$allele_frequency[subjectHits(XHMMxgnomADlaps)]
                )

GATKgnomADoverlap <- data.frame(
                        sample = GATKranges$sample[queryHits(GATKxgnomADlaps)],
                        chr = as.data.frame(GATKranges)$seqnames[queryHits(GATKxgnomADlaps)],
                        start = as.data.frame(GATKranges)$start[queryHits(GATKxgnomADlaps)],
                        end = as.data.frame(GATKranges)$end[queryHits(GATKxgnomADlaps)],
                        query=queryHits(GATKxgnomADlaps), 
                        subject=subjectHits(GATKxgnomADlaps),
                        GATKxgnomAD_sect_width=width(GATKxgnomADsect),
                        GATKxgnomAD_union_width=width(GATKxgnomADunion),
                        pctOverlap = round(width(GATKxgnomADsect)/width(GATKxgnomADunion), 2),
                        allele_frequency = as.data.frame(gnomADranges)$allele_frequency[subjectHits(GATKxgnomADlaps)]
                         )
                        
## I WANT TO GO BACK THROUGH THE QUERY VALUES FROM "myDels OR delCallsLCfamilies" TO ADD THE MAX (ORDER FUNCTION)PCT OVERLAP OF EACH QUERY TO GNOMAD.
# WILL BE ABLE TO DO THE SAME THING FOR MARRIED-INS. THIS WILL WORK BETTER
# AS I LOOP THROUGH THE DATAFRAMES, I MUST EXAM ONLY THOSE THAT ARE > .75 UNION/INTERSECTION AND THEN TAKE MAX ALLELE FREQUENCY

delCallsLCfamiliesGnomADolapByAlg <- cbind(delCallsLCfamilies[,c(1:6,11:15)], data.frame(GATKgnomAD70pctOverlapMaxAF = NA, XHMMgnomAD70pctOverlapMaxAF = NA, GATKmarriedInpctOverlapMax = NA, XHMMmarriedInpctOverlapMax = NA))

B <- XHMMgnomADoverlap

        for(j in unique(B$query)){ # j = unique(B$query)[42] # 
                    pctByQuery <- B[which(B$query==j), c("pctOverlap", "allele_frequency")]
                    pctByQueryG70 <- pctByQuery[which(pctByQuery$pctOverlap > 0.7),]
                    topAF <- pctByQueryG70[order(pctByQueryG70$allele_frequency, decreasing = TRUE),2]
                    delCallsLCfamiliesGnomADolapByAlg$XHMMgnomAD70pctOverlapMaxAF[j] <- as.numeric(topAF[1])
                    
            } # for j (rows in gnomADoverlap)
  
C <- GATKgnomADoverlap
        for(j in unique(C$query)){ # j = unique(C$query)[44] # 
                    pctByQuery <- C[which(C$query==j), c("pctOverlap", "allele_frequency")]
                    pctByQueryG70 <- pctByQuery[which(pctByQuery$pctOverlap > 0.7),]
                    topAF <- pctByQueryG70[order(pctByQueryG70$allele_frequency, decreasing = TRUE),2]
                    delCallsLCfamiliesGnomADolapByAlg$GATKgnomAD70pctOverlapMaxAF[j] <- as.numeric(topAF[1])
                    
            } # for j (query in gnomADoverlap)
 # save(delCallsLCfamiliesGnomADolapByAlg, delCallsLCfamilies, delCallsMarriedIn, familyPhenotypes, olapCNVs, pheno, file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/03.15.22.delCallsLCfamiliesGnomADolapByAlg.rda")

############################################ olaps with Married-Ins ############################################
#already have: GATKranges & XHMMranges
# now need Married-In Ranges: 

# first need to remove "chr" from seqnames in delCallsMarriedIn
l <- strsplit(delCallsMarriedIn$chr, "chr") 
numb <- sapply(l, "[", 2)
delCallsMarriedIn$chr <- numb

B <- makeGRangesFromDataFrame(delCallsMarriedIn[,-c(5,6)], keep.extra.columns=TRUE)

#overlaps
    GATKxMarriedInlaps <- findOverlaps(GATKranges, B)
    XHMMxMarriedInlaps <- findOverlaps(XHMMranges, B)
   #intersection 
   GATKxMarriedInsect <- pintersect(GATKranges[queryHits(GATKxMarriedInlaps)], B[subjectHits(GATKxMarriedInlaps)])
   XHMMxMarriedInsect <- pintersect(XHMMranges[queryHits(XHMMxMarriedInlaps)], B[subjectHits(XHMMxMarriedInlaps)])
   #union 
    GATKxMarriedInunion <- punion(GATKranges[queryHits(GATKxMarriedInlaps)], B[subjectHits(GATKxMarriedInlaps)])
    XHMMxMarriedInunion <- punion(XHMMranges[queryHits(XHMMxMarriedInlaps)], B[subjectHits(XHMMxMarriedInlaps)])

# build data.frame with overlap pct for married ins (GATK calls)
XHMMmarriedINoverlap <- data.frame(
                sample = XHMMranges$sample[queryHits(XHMMxMarriedInlaps)],
                chr = as.data.frame(XHMMranges)$seqnames[queryHits(XHMMxMarriedInlaps)],
                start = as.data.frame(XHMMranges)$start[queryHits(XHMMxMarriedInlaps)],
                end = as.data.frame(XHMMranges)$end[queryHits(XHMMxMarriedInlaps)],
                query=queryHits(XHMMxMarriedInlaps), 
                subject=subjectHits(XHMMxMarriedInlaps),
                XHMMxgnomAD_sect_width=width(XHMMxMarriedInsect),
                XHMMxgnomAD_union_width=width(XHMMxMarriedInunion),
                pctOverlap = round(width(XHMMxMarriedInsect)/width(XHMMxMarriedInunion), 2)
                                )

GATKmarriedINoverlap <- data.frame(
                        sample = GATKranges$sample[queryHits(GATKxMarriedInlaps)],
                        chr = as.data.frame(GATKranges)$seqnames[queryHits(GATKxMarriedInlaps)],
                        start = as.data.frame(GATKranges)$start[queryHits(GATKxMarriedInlaps)],
                        end = as.data.frame(GATKranges)$end[queryHits(GATKxMarriedInlaps)],
                        query=queryHits(GATKxMarriedInlaps), 
                        subject=subjectHits(GATKxMarriedInlaps),
                        GATKxgnomAD_sect_width=width(GATKxMarriedInsect),
                        GATKxgnomAD_union_width=width(GATKxMarriedInunion),
                        pctOverlap = round(width(GATKxMarriedInsect)/width(GATKxMarriedInunion), 2)
                                                 )

# build pct overlap values back into "delCallsLCfamiliesGnomADolapByAlg"
 
B <- XHMMmarriedINoverlap

        for(j in unique(B$query)){ # j = unique(B$query)[42] # 
                    pctByQuery <- B[which(B$query==j), c("pctOverlap")]
                    topPct <- pctByQuery[order(pctByQuery, decreasing = TRUE)]
                    delCallsLCfamiliesGnomADolapByAlg$XHMMmarriedInpctOverlapMax[j] <- as.numeric(topPct[1])
                    
            } # for j (rows in gnomADoverlap)
  
C <- GATKmarriedINoverlap
        for(j in unique(C$query)){ # j = unique(C$query)[44] # 
                   pctByQuery <- C[which(C$query==j), c("pctOverlap")]
                   topPct <- pctByQuery[order(pctByQuery, decreasing = TRUE)]
                   delCallsLCfamiliesGnomADolapByAlg$GATKmarriedInpctOverlapMax[j] <- as.numeric(topPct[1])
                    
            } # for j (query in gnomADoverlap)

# save(delCallsLCfamiliesGnomADolapByAlg, delCallsLCfamilies, delCallsMarriedIn, familyPhenotypes, olapCNVs, pheno, file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/03.15.22.delCallsLCfamiliesGnomADolapANDmarriedINSByAlg.rda")
################################################################################################################################################################################################

# subset to those calls with AF < 0.05
delBothCallsLCfamiliesUncommon <- overlappingCNVsWgnomAD[-which(overlappingCNVsWgnomAD$allele_frequency > 0.05),]
################################ delBothCallsLCfamiliesUncommon  <- subset(overlappingCNVsWgnomAD, is.na(overlappingCNVsWgnomAD$allele_frequency) | overlappingCNVsWgnomAD$allele_frequency < 0.05)
# nrow(overlappingCNVsWgnomAD) vs. nrow(delBothCallsLCfamiliesUncommon)::

# ID different objects at this point after filter steps
        # overlappingCNVs # all those deletions called by both XHMM and GATK4.0 with any overlap
        # overlappingCNVsPostRemoved # only CNVs common to both algorithms minus redundant GATK CNVs for single XHMM CNVs with lower phred score
        # delCallsLCfamilies # overlappingCNVsPostRemoved minus married-in samples # nrow(delCallsLCfamilies) # = 3489
        # myDels #  numeric chromosomes and removeal of no.olaps from delCallsLCfamilies
        # overlappingCNVsWgnomAD # myDels table of individuals both calls and insertion of AF and percent overlap of calls from gnomad with greater 75% intersection/union (G75pctGnomAD)
        # delBothCallsLCfamiliesUncommon # overlappingCNVsWgnomAD minus those with AF > 0.05 # nrow(delBothCallsLCfamiliesUncommon) #= 3211

#####################################################################################################################
# create table grouped by gene that includes deletions in genes that affect at least 3 individuals.

delBothCallsLCfamiliesUncommonGeneIDs <- unlist(strsplit(delBothCallsLCfamiliesUncommon$XHMMgene, split = ", "))  # length(unique(delCallsLCfamiliesgeneIDs)) = now (9/30/21) 813, prior to 9/30/21 it was 566

freq <-table(delBothCallsLCfamiliesUncommonGeneIDs) # freq <-table(delBothCallsLCfamiliesUncommonGeneIDs[delBothCallsLCfamiliesUncommonGeneIDs != "NA"]) 
genelistG2 <- as.data.frame(freq)[as.data.frame(freq)[,2]>2,]
colnames(genelistG2) <- c("gene", "Freq")

allGenesInG2CIND <- data.frame() 
for (j in 1:length(genelistG2$gene)){    #j=1
      loc <- vector()
      for(i in 1:length(delBothCallsLCfamiliesUncommon$XHMMgene)){ # i=1
              if (genelistG2$gene[j] %in% strsplit(delBothCallsLCfamiliesUncommon$XHMMgene, split = ", ")[[i]]){
              loc <- c(loc, i)}
                          
              } # i
      cat("working on ", as.vector(genelistG2$gene)[j], "\n")

# match sample in delBothCallsLCfamiliesUncommon (cnvs with only dels, minus married-ins, minus AF > 0.05) to sample in phenoFam: CID and CIND, "CF", "CM", "diagnosis.of.lung.throat.pharynx.larynx.cancer", "Age.at.Onset.1o.cancer"
      family <- delBothCallsLCfamiliesUncommon[loc,c(1:4, 11,16:20)] 
      for(w in 1:length(family$sample)){    # w = 2
         family[w,"CID"] <- phenoFam[which(phenoFam$submitted.sample.id == family$sample[w]), "CID"]
         family[w,"CIND"] <- phenoFam[which(phenoFam$submitted.sample.id == family$sample[w]), "CIND"]
         family[w,"CF"] <- phenoFam[which(phenoFam$submitted.sample.id == family$sample[w]), "CF"]
         family[w,"CM"] <- phenoFam[which(phenoFam$submitted.sample.id == family$sample[w]), "CM"]
         family[w, "SEX"] <- phenoFam[which(phenoFam$submitted.sample.id == family$sample[w]), "SEX"]
         family[w,"diagnosis.of.lung.throat.pharynx.larynx.cancer"] <- phenoFam[which(phenoFam$submitted.sample.id == family$sample[w]), "diagnosis.of.lung.throat.pharynx.larynx.cancer"]
         family[w,"Age.at.Onset.1o.cancer"] <- phenoFam[which(phenoFam$submitted.sample.id == family$sample[w]), "Age.at.Onset.1o.cancer"]
         } # w
   #label this information with the gene of interest
   family$gene <- genelistG2$gene[j]

allGenesInG2CIND <- rbind(allGenesInG2CIND, family)
            } # j 

### running through loops to organize by gene 10/13/21 11:00am - two hours in, still in the genes starting with the letter A.
### closing the R gui window that had a help article sped up the process. 
# def want to save this table to avoid running this again if possible.
write.csv(allGenesInG2CIND, file= "C:/Users/4wald/OneDrive - LSUHSC/GELCC/10.13.21.allGenesInG2CIND.csv")
# allGenesInG2CIND <- read.csv(file= "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/10.13.21.allGenesInG2CIND.csv")

# prior to first removing common (AF > 0.05) # save(allGenesInG2CIND, overlappingCNVs, overlappingCNVsPostRemoved, GATKcnv, XHMMcnv, phenoFam, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/10.3.21.upToAllDataOrganizedByGene.rda")
# load(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/9.30.21.upToAllDataOrganizedByGene.rda")
#### Now time for branch point - all those genes in 3 families at least 2 individuals per family and those in < 3 families but > 4(3?) individuals per family
# frankly, that (above line) should be easy to subset

############################################################################################################################################################################
delBothCallsLCfamiliesUncommon[which(delBothCallsLCfamiliesUncommon$sample=="H_NK-12GELCC37-12037"),]
############################################################################################################################################################################
# organize to determine how many per family 
geneSummary <- as.data.frame(matrix(nrow=0, ncol=8))
colnames(geneSummary) <- c("gene", "numCIDs", "numCIDs.with.>2ind", "numCINDs", "num_affected", "num_unaffected", "mean_width", "num_unique_widths")

for(i in unique(allGenesInG2CIND$gene)){    #i = cumgFamily$gene[1]
     peeps <- subset(allGenesInG2CIND, allGenesInG2CIND$gene %in% i)
     k=0
     for(j in unique(peeps$CID)) {    #j=peeps$CID[1]
         if(length(which(peeps$CID %in% j))>1){ k=k+1 }
            } # j
     geneSummary <- rbind(geneSummary, data.frame(i, length(unique(peeps$CID)), 
                                         k, length(peeps$CIND), 
                                         length(which(peeps$diagnosis.of.lung.throat.pharynx.larynx.cancer)),
                                         length(which(peeps$diagnosis.of.lung.throat.pharynx.larynx.cancer==FALSE)),
                                         round(mean(as.numeric(peeps$GATKend)-as.numeric(peeps$GATKstart)), 1), 
                                         length(unique(as.numeric(peeps$GATKend)-as.numeric(peeps$GATKstart)))))
     # this could be a great place to use a statistical test of association between Dx and cnv width, CID and CNV width, or                         
     
     cat(i, " has ",  length(unique(peeps$CID)), " CIDs and ", k, " families with > 2 CINDs with this CNV\n")   
     } # i
     colnames(geneSummary) <- c("gene", "numCIDs", "numCIDs.with.>2ind", "numCINDs", "num_affected", "num_unaffected", "mean_width", "num_unique_widths")

write.table(geneSummary, file= "C:/Users/4wald/OneDrive - LSUHSC/GELCC/statsByGene.10.13.21.csv", row.names=FALSE, sep =",")                                         

# write.table(geneSummary, file= "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/statsByGene.10.1.21.csv", row.names=FALSE, sep =",")                                                                                  
# geneSummary <- read.csv(file= "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/statsByGene.10.1.21.csv")                                         

# now screen out all genes where geneSummary[,2] < 3 | geneSummary[,3] < 3

G2FamiliesWithG2per <- subset(geneSummary, geneSummary[,3] > 2)
G2FamiliesWithG2per <- rbind(G2FamiliesWithG2per, geneSummary[which(geneSummary$gene=="SSX1"),])

write.table(G2FamiliesWithG2per, file= "C:/Users/4wald/OneDrive - LSUHSC/GELCC/G2FamiliesWithG2per.10.13.21.csv", row.names=FALSE, sep =",") 
# write.table(G2FamiliesWithG2per, file= "C:/Users/4wald/OneDrive - LSUHSC/GELCC/G2FamiliesWithG2per.10.4.21.csv", row.names=FALSE, sep =",")  
# G2FamiliesWithG2per <- read.csv(file= "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/G2FamiliesWithG2per.10.13.21.csv")

#####################################################################################################################
# trying out CNVannotator (https://bioinfo.uth.edu/CNVannotator/cnv_onestop.cgi) ##!!! FAILURE - no output even with their example input
example: chr1:10001:87113;
x <- paste("chr", delBothCallsLCfamiliesUncommon[1:500,2], ":", delBothCallsLCfamiliesUncommon[1:500,3], ":", delBothCallsLCfamiliesUncommon[1:500,4], ";", sep="")
write(x, file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/1.14.21first500delBothCallsLCfamiliesUncommon.txt")#, quote=FALSE, sep="\t", row.names=FALSE)

# trying CLinTAD
# try multiple regions, single phenotype
# HP: 0100526
        g <- grep(G5FamiliesWithG2perSSX1[15,1], delBothCallsLCfamiliesUncommon$XHMMgene)
        x <- paste(delBothCallsLCfamiliesUncommon[g,1], "\t", "Chr", delBothCallsLCfamiliesUncommon[g,2], ":",
                delBothCallsLCfamiliesUncommon[g,3], "-", delBothCallsLCfamiliesUncommon[g,4], "\t0100526",
                sep="")
            write(x, file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/1.14.21.SSX1.txt")#, quote=FALSE, sep="\t", row.names=FALSE)
      
# create gene list of ~100 to exam, include SSX1 
geneSummary <- read.csv(file= "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/statsByGene.10.1.21.csv")                                         
# G2FamiliesWithG2per <- read.csv(file= "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/G2FamiliesWithG2per.10.13.21.csv")

G3FamiliesWithG2per <- subset(geneSummary, geneSummary[,3] > 3) # nrow = 148
G4FamiliesWithG2per <- subset(geneSummary, geneSummary[,3] > 4) # nrow = 119
G5FamiliesWithG2per <- subset(geneSummary, geneSummary[,3] > 5) # nrow = 95 
G5FamiliesWithG2perSSX1 <- rbind(G5FamiliesWithG2per, geneSummary[which(geneSummary$gene=="SSX1"),])
# create table to use for and add information from SORVO
write.csv(G5FamiliesWithG2perSSX1, file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/SORVOtable.csv")#, quote=FALSE, sep="\t", row.names=FALSE)
####################################################################################################################

# compare with DGV # form download at http://dgv.tcag.ca/dgv/app/downloads?ref= link to hg19/GRCh37 curated 2020-02-25
DGV <- read.delim(file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/DGV_GRCh37_hg19_variants_2020-02-25.txt")

# CNVs appear to be primarily classified as "gain" or "loss" despite the following options: 
# unique(DGV$varianttype) returns [1] "CNV"   "OTHER"

# unique(DGV$variantsubtype)
# [1] "loss"                     "duplication"
# [3] "gain+loss"                "complex"
# [5] "deletion"                 "gain"
# [7] "insertion"                "alu insertion"
# [9] "sequence alteration"      "mobile element insertion"
# [11] "line1 deletion"           "novel sequence insertion"
# [13] "sva insertion"            "tandem duplication"
# [15] "alu deletion"             "line1 insertion"
# [17] "inversion"                "mobile element deletion"
# [19] "sva deletion"             "herv deletion"
# [21] "herv insertion"

# limit input to deletions # nrow(DGV) = 826661; nrow(DGVloss) = 130930
DGVloss <- DGV[grep("loss", DGV$variantsubtype),] # ### length(grep("DEL", gnomAD$sv_type)) = 169635


#  step to ID those segments in allGenesInG2CIND which excludes: 
# married-in CINDs, multiple GATK calls for a single XHMM, calls not made by both XHMM and GATK, anything but deletions, 
# gnomAD AF > 0.05, and present in less than 2 individuals
allGenesInG2CIND <- read.csv(file= "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/10.13.21.allGenesInG2CIND.csv")

A <- makeGRangesFromDataFrame(allGenesInG2CIND, keep.extra.columns=TRUE) 
B <- makeGRangesFromDataFrame(DGVloss, keep.extra.columns=TRUE)

#### percent overlap between A and B defined by the ratio of the intersection of A and B to the union of A and B.

    ABlaps <- findOverlaps(A, B)
    ABsect <- pintersect(A[queryHits(ABlaps)], B[subjectHits(ABlaps)])
    ABunion <- punion(A[queryHits(ABlaps)], B[subjectHits(ABlaps)])
      
###########################
    DGVoverlap <- data.frame(
                sample = A$sample[queryHits(ABlaps)],
                chr = as.data.frame(A)$seqnames[queryHits(ABlaps)],
                GATKstart = as.data.frame(A)$start[queryHits(ABlaps)],
                GATKend = as.data.frame(A)$end[queryHits(ABlaps)],
                DGVstart = as.data.frame(B)$start[subjectHits(ABlaps)],
                DGVend = as.data.frame(B)$end[subjectHits(ABlaps)],
                query=queryHits(ABlaps), 
                subject=subjectHits(ABlaps),
                intersection_width=width(ABsect), 
                union_width=width(ABunion),
                pctOverlap = round(width(ABsect)/width(ABunion), 2),
                GELCC_genes = as.data.frame(A)$gene[queryHits(ABlaps)],
                DGV_genes = as.data.frame(B)$genes[subjectHits(ABlaps)],
                DGV_variantaccession = as.data.frame(B)$variantaccession[subjectHits(ABlaps)],
                allele_frequency = as.data.frame(B)$frequency[subjectHits(ABlaps)])


# now subset DGVoverlap to only those with > 75% intersection/union
pctDGVoverlap <- DGVoverlap[which(DGVoverlap$pctOverlap > .25),] # nrow(G75pctDGVoverlap) = 5458

# order by percent overlap
pctDGVoverlap <- pctDGVoverlap[order(-pctDGVoverlap$pctOverlap), ]

# created new data table to fill in allele frequencies and pct overlap values for CNV/dels with at least 75% of intersection/union with DGV calls 
x <- c()
overlappingCNVsWithDGV <- cbind(allGenesInG2CIND, data.frame(DGVoverlap = NA, DGV_variantaccession = NA, DGVoverlap2 = NA, DGV_variantaccession2 = NA, DGVoverlap3 = NA, DGV_variantaccession3 = NA, DGVoverlap4 = NA, DGV_variantaccession4 = NA))
    for(i in 1:nrow(overlappingCNVsWithDGV)){ # i = 10
        for(j in 1:nrow(pctDGVoverlap)){ # j = 4
            if(overlappingCNVsWithDGV$sample[i] == pctDGVoverlap$sample[j] &&
               overlappingCNVsWithDGV$chr[i] == pctDGVoverlap$chr[j] &&
               overlappingCNVsWithDGV$GATKstart[i] == pctDGVoverlap$GATKstart[j] &&
               overlappingCNVsWithDGV$GATKend[i] == pctDGVoverlap$GATKend[j]) {
                    if(is.na(overlappingCNVsWithDGV$DGVoverlap[i])) { 
                                overlappingCNVsWithDGV$DGVoverlap[i] <- pctDGVoverlap$pctOverlap[j]
                                overlappingCNVsWithDGV$DGV_variantaccession[i] <- pctDGVoverlap$DGV_variantaccession[j]
                                } else if(is.na(overlappingCNVsWithDGV$DGVoverlap2[i])) {
                                overlappingCNVsWithDGV$DGVoverlap2[i] <- pctDGVoverlap$pctOverlap[j]
                                overlappingCNVsWithDGV$DGV_variantaccession2[i] <- pctDGVoverlap$DGV_variantaccession[j]
                                } else if(is.na(overlappingCNVsWithDGV$DGVoverlap3[i])) {
                                overlappingCNVsWithDGV$DGVoverlap3[i] <- pctDGVoverlap$pctOverlap[j]
                                overlappingCNVsWithDGV$DGV_variantaccession3[i] <- pctDGVoverlap$DGV_variantaccession[j]
                                } else {
                                overlappingCNVsWithDGV$DGVoverlap4[i] <- pctDGVoverlap$pctOverlap[j]
                                overlappingCNVsWithDGV$DGV_variantaccession4[i] <- pctDGVoverlap$DGV_variantaccession[j]
                                cat("found an overwrite at row", i, "\n")
                                x <- c(x, i) # tracking which rows get to 4th overlap
                                } # else (not na @ 1-3 )
                    
                    } # if matches [,1:4]
            } # for j (rows in pctDGVoverlap)
      } # for i (rows in overlappingCNVsWithDGV
              
      
write.csv(overlappingCNVsWithDGV, file ="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/10.19.21.overlappingCNVsWithDGV.csv")

####################################################################################################################
# identify other CNVs in family 12 (applicable to any family or individual)
allGenesInG2CIND <- read.csv(file= "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/10.13.21.allGenesInG2CIND.csv")
write.csv(allGenesInG2CIND[,2:ncol(allGenesInG2CIND)], file= "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/10.20.21.allGenesInG2CIND.csv", row.names=FALSE)
allGenesInG2CIND <- read.csv(file= "C:/Users/4wald/OneDrive - LSUHSC/GELCC/10.20.21.allGenesInG2CIND.csv")

# for overlappingCNVsWgnomAD # which includes nomad data for >75% intersection/union from delCallsLCfamilies
# load(file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/overlappingCNVsWgnomAD.10.13.21.rda")
head(allGenesInG2CIND)
cols <- c("CID", "CIND", "CF", "CM", "SEX", "diagnosis.of.lung.throat.pharynx.larynx.cancer", 
        "Age.at.Onset.1o.cancer", "chr", "GATKstart", "GATKend", "GATKcall.copyNum", "gene")
allGenesInG2CIND[which(allGenesInG2CIND$CID==12), cols]

t <- table(allGenesInG2CIND[which(allGenesInG2CIND$CID==12), "gene"])
png(file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/frequencyAffectedGenesInFamily12.png")
hist(t)
dev.off()
write.csv(t, file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/tableAffectedGenesInFamily12.csv", row.names=FALSE)
tdf <- as.data.frame(t)
colnames(tdf) <- c("gene", "freqency")
write.csv(tdf[which(tdf[,2] > 2),], file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/tableAffectedGenesInFamily12inMoreThan2CINDs.csv", row.names=FALSE)

# create table of sample name, CID, CIND, GATKstart, GATKend, geneStartcodon, geneStopCodon 
cols <- c("CID", "CIND", "diagnosis.of.lung.throat.pharynx.larynx.cancer", 
        "Age.at.Onset.1o.cancer", "chr", "GATKstart", "GATKend", "GATKcall.copyNum", "gene")
        # , "CDSstart", "CDSend"
g <- allGenesInG2CIND[which(allGenesInG2CIND$CID==12), cols]
g <- g[which(g$gene %in% tdf[which(tdf[,2] > 2),1]),]

CDS = genes(Homo.sapiens, columns=c("CDSSTART", "CDSEND", "SYMBOL"))
cdsdf <- as.data.frame(CDS)

# because there are multiple start and end for CDSs, I'll choose min star and max end?
CDSstart <- c()
CDSend <- c()
strnd <- character()
# cdsdf[which(cdsdf$SYMBOL==g$gene[i]),]
for(i in 1:nrow(g)){ # i = 37
    CDSstart <- c(CDSstart, min(cdsdf$CDSSTART[which(cdsdf$SYMBOL==g$gene[i])][[1]]))
    CDSend <- c(CDSend, max(cdsdf$CDSEND[which(cdsdf$SYMBOL==g$gene[i])][[1]]))
    strnd <-  c(strnd, as.character(cdsdf$strand[which(cdsdf$SYMBOL==g$gene[i])]))
} # for i

# df <- cbind(CDSstart, CDSend, strnd)
# CDSstart[is.na(CDSstart)] <- "noncoding"

gb <- cbind(g, strnd, CDSstart, CDSend)

write.csv(gb, file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/tableAffectedGenesFamily12inMoreThan2CINDsCoordinatesBySample.csv", row.names=FALSE)

b <- data.frame()
for(i in unique(gb$gene)){ # i = unique(gb$gene)[1]
    CIND <- paste(gb$CIND[which(gb$gene == i)], collapse=",")
    chr <- gb$chr[which(gb$gene == i)][1]
    GATKstartMin <- min(gb$GATKstart[which(gb$gene == i)])
    GATKendMax <- max(gb$GATKend[which(gb$gene == i)])
    gene <- i
    strnd <- gb$strnd[which(gb$gene == i)][1]
    CDSstart <- gb$CDSstart[which(gb$gene == i)][1]
    CDSend <- gb$CDSend[which(gb$gene == i)][1]
    b <- rbind (b, cbind(CIND, chr, GATKstartMin, GATKendMax, gene, strnd, CDSstart, CDSend))
} # for i in unique genes

write.csv(b, file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/summaryTableAffectedGenesFamily12inMoreThan2CINDs.csv", row.names=FALSE)


#Rterm.exe --vanilla
library(Homo.sapiens) 
geneRanges <- 
    function(db, column="ENTREZID")
{
    g <- genes(db, columns=column) #, single.strand.genes.only=ss) # No matter what I do, including single.strand.genes.only= FALSE returns: Error in .local(x, ...) : unused argument (single.strand.genes.only = FALSE)
    col <- mcols(g)[[column]]
    genes <- granges(g)[rep(seq_along(g), elementNROWS(col))]
    mcols(genes)[[column]] <- as.character(unlist(col))
    genes
}
# what columns are available?
# columns(Homo.sapiens)
# find gene stop and start codon locations
gns = geneRanges(Homo.sapiens, column="SYMBOL")
CDSstart = geneRanges(Homo.sapiens, column="CDSSTART")


cdsByOVerlaps

t <- transcripts(Homo.sapiens)
g <- genes(Homo.sapiens)

# splitByOverlap genes, transcripts, CDS by GATKcnvGranges
gns_symInCnv = splitByOverlap(gns, GATKcnvGranges, "SYMBOL")
trnscrpts_symInCnv = splitByOverlap(trnscrpts, GATKcnvGranges, "SYMBOL")
coding_symInCnv = splitByOverlap(coding, GATKcnvGranges, "SYMBOL")
entrez_symInCnv = splitByOverlap(EID, GATKcnvGranges, "ENTREZID")

# GATK - loop through each CNV listed in each table from each algorithm
for(i in 1:nrow(GATKcnv)){
cat("GATKcnv #", i, " covers ", paste(gns_symInCnv[[i]][!is.na(gns_symInCnv[[i]])], collapse=", "), "\n")
GATKcnv$gene[i] <-  paste(gns_symInCnv[[i]][!is.na(gns_symInCnv[[i]])], collapse=", ")
           }

write.csv(g, file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/tableAffectedGenesFamily12inMoreThan2CINDsCoordinates.csv", row.names=FALSE)

#####################################################################################################################
# ID different objects at this point after filter steps
        # overlappingCNVs # all those deletions called by both XHMM and GATK4.0 with any overlap
        # overlappingCNVsPostRemoved # only CNVs common to both algorithms minus redundant GATK CNVs for single XHMM CNVs with lower phred score
        # delCallsLCfamilies # overlappingCNVsPostRemoved minus married-in samples # nrow(delCallsLCfamilies) # = 3489
        # myDels #  numeric chromosomes and removeal of no.olaps from delCallsLCfamilies
        # overlappingCNVsWgnomAD # myDels table of individuals both calls and insertion of AF and percent overlap of calls from gnomad with greater 75% intersection/union (G75pctGnomAD)
        # delBothCallsLCfamiliesUncommon # overlappingCNVsWgnomAD minus those with AF > 0.05 # nrow(delBothCallsLCfamiliesUncommon) #= 3211
        # allGenesInG2CIND # data frame as above but only including deletions that affect genes that are in at least 2 individuals # it has more rows because some sgements cover more than one gene and now each gene has its own row # nrow(allGenesInG2CIND) = 5976
        # geneSummary # allGenesInG2CIND organized with one row per gene with the frequency that gene is affected in these LC families and how many families have 2 or more affected individuals
        # 
        # G3FamiliesWithG2per <- subset(geneSummary, geneSummary[,3] > 3) # nrow = 148
        # G4FamiliesWithG2per <- subset(geneSummary, geneSummary[,3] > 4) # nrow = 119
        # G5FamiliesWithG2per <- subset(geneSummary, geneSummary[,3] > 5) # nrow = 95
        # G5FamiliesWithG2perSSX1 <- rbind(G5FamiliesWithG2per, geneSummary[which(geneSummary$gene=="SSX1"),])
# save(allGenesInG2CIND, overlappingCNVs, genelistG2, overlappingCNVsPostRemoved, delBothCallsLCfamiliesUncommon,
    GATKcnv, XHMMcnv, phenoFam, delBothCallsLCfamiliesUncommonGeneIDs, allGenesInG2CIND, geneSummary, G2FamiliesWithG2per,
    file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/10.15.21.upToAllDataOrganizedByGeneWithGeneListsByFilterSteps.rda")
# load(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/10.15.21.upToAllDataOrganizedByGeneWithGeneListsByFilterSteps.rda")
#####################################################################################################################
# create FBAT input
# load(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/10.3.21.upToAllDataOrganizedByGene.rda")

######### make the map file #############################################################################################################################
### 10/6/21 - after 7 hours of trying, FBAT wants two alleles listed, but only one marker

# The map file uses the following format:
# marker_name chr# genetic_pos physical_pos sex_link
# The count of the markers and the order in which they are listed in the map file must be the same as in the ped file. Chr# is
# set to 23 for an X-chromosome marker, and 24 for Y.
# Sex_link = 1 if the marker is sex linked, 0 otherwise. If sex_link = 1, fbat will implement an analysis for an x-chromosome
# marker. For autosomal markers, and for markers in the pseudoautosomal region of the x-marker, set sex-link to zero.

# necessary for "between()" function
 library(dplyr)

#changing no.olaps chr# from NA to no.olaps creates an error for IRanges in loops below,
# must remove the sample that had no XHMM and GATK overlaps from running through these loops
overlappingCNVsPostRemoved <- overlappingCNVsPostRemoved[-grep("no.olaps", overlappingCNVsPostRemoved$chr),]

# replace chr numbers with JUST numbers 23 for X, 24 for Y
    l <- strsplit(overlappingCNVsPostRemoved$chr, "chr")
    numb <- sapply(l, "[", 2)
    numb[which(numb=="X")] <- 23
    numb[which(numb=="Y")] <- 24
    overlappingCNVsPostRemoved$chr <- as.numeric(numb)

# use this variable to easily switch the df of segs from which the map file is created: must have segs and chr information
    seg.df <- overlappingCNVsPostRemoved # the gene list is what really limits the map file, this is just for information like chr and coordinates corresponding the genes chosen from the list
# use this variable to easily switch the filtered gene list to include in the map file
    filteredGenes <- G2FamiliesWithG2per$gene
map <- as.data.frame(matrix(nrow=0, ncol=5))
colnames(map) <- c("marker_name", "chr", "genetic_pos", "physical_pos", "sex_link")
for (i in unique(seg.df$chr)){ # i = unique(seg.df$chr)[10] #overlappingCNVsPostRemoved[which(is.na(overlappingCNVsPostRemoved$chr)),]
    byChr <- subset(seg.df, seg.df$chr == i)
        # for each gene on chr i, determine how many nonoverlapping deletions have been identified. 
        # each nonoverlapping deletion will be listed as a different marker
        #clear segs
        segs <- vector()
        # create vector of genes in unique(unlist(strsplit(byChr$XHMMgene, ", "))) and in G2FamiliesWithG2per$gene # G2FamiliesWithG2per does not have chr info attached (future go back and add it, or now overlap with genes subset to this chr)
        limitedGenesInThisChr <- filteredGenes[which(filteredGenes %in% unique(unlist(strsplit(byChr$XHMMgene, ", "))))]
        for (j in limitedGenesInThisChr) { # j = limitedGenesInThisChr[5] 
                Ustart <- byChr$GATKstart[grep(j, byChr$XHMMgene)] 
                Uend <- byChr$GATKend[grep(j, byChr$XHMMgene)]
                sample <- byChr$sample[grep(j, byChr$XHMMgene)]
                segs <- cbind(start = as.numeric(Ustart), end = as.numeric(Uend))
                segs <- data.frame(sample = sample, chr = i, start = segs[,1], end = segs[,2], physicalPos = rowMeans(segs)) 
                A <- makeGRangesFromDataFrame(segs, keep.extra.columns=TRUE) 
                            # ABlaps <- findOverlaps(A, invert=TRUE)
                            # ABsect <- pintersect(A[queryHits(ABlaps)], B[subjectHits(ABlaps)])
                w <- A %outside% A # %outside% is the inverse of overlapsAny() or the convenience wrapper %over% 
                #initiate and clear imap for each j before running through k
                imap <- as.data.frame(matrix(nrow=0, ncol=5))
                colnames(map) <- c("marker_name", "chr", "genetic_pos", "physical_pos", "sex_link")    
                for (p in 1:(length(which(w))+1)){ # p = 1 ## intended to be unique non overlapping segments!!!!!!!!!!!!!!!!!
                         if(p > 1) n <- paste(j, p, sep="") else n <- j
                         imap <- rbind(imap, data.frame(
                                       marker_name = n, 
                                       chr = i,
                                       genetic_pos = round(segs$physicalPos[p]), 
                                       physical_pos = round(segs$physicalPos[p]),
                                       sex_link = 0))
                                        ########################### previous # produces marker_1 only###############################################
                                        #imap <- rbind(imap, data.frame(marker_name = paste(j, p, sep="_"),  chr = i, genetic_pos = round(segs$physicalPos[p]), physical_pos = round(segs$physicalPos[p]), sex_link = 0))
                                        # previuos produces 2 markers
                                        # imap <- rbind(imap, data.frame(marker_name = paste(j, c(p, p+1), sep="_"), chr = c(i,i), genetic_pos = c(round(segs$physicalPos[p]), round(segs$physicalPos[p])),  physical_pos = c(round(segs$physicalPos[p]),round(segs$physicalPos[p])), sex_link = c(0,0)))
                                        ############################################################################################################                          
                   } # for p
            if(i == 23 | i == 24) sl = 1 else sl = 0
            imap$sex_link <- sl
            map <- rbind(map, imap)
            } # for j
      
       } # for i

# fbat does not want col.names, i was getting error for chr#, because it does not want col.names in input map
colnames(map) <- c("marker_name", "chr#", "genetic_pos", "physical_pos", "sex_link")

write.table(map, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/176.G2FamG2per10.15.21.map", quote = FALSE, col.names = FALSE, row.names = FALSE, sep = "\t")
# previous interation to explain origin of file # write.table(map, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/oneMarker197genesG2FamG2per10.6.21.map", quote = FALSE, col.names = FALSE, row.names = FALSE, sep = "\t")

# map <- read.delim(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/oneMarker197genesG2FamG2per10.6.21.map")
# colnames(map) <- c("marker_name", "chr#", "genetic_pos", "physical_pos", "sex_link")

#####################################################################################################################
# use allGenesInG2CIND for all pedigree and affected info (10/3/21 wnt back to add sex info)
# Layout: ".ped"
# (optional)First line: names of all markers in the sequence of the genotype data
# Remaining lines: pid id fid mid sex aff A11 A12 A21 A22
# aff --> 2 = affected, 1 = unaffected, 0 = unknown
# Alleles are represented by positive integers. Use 0 (zero) for missing alleles: allele j of marker i (j = 1, 2;i = 1, 2, . . .)

# load(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/10.3.21.upToAllDataOrganizedByGene.rda")
# [1] "allGenesInG2CIND"           "GATKcnv"
# [3] "overlappingCNVs"            "overlappingCNVsPostRemoved"
# [5] "phenoFam"                   "XHMMcnv"

# length(G2FamiliesWithG2per$gene) # = 197
# G2FamiliesWithG2per <- read.csv(file= "C:/Users/4wald/OneDrive - LSUHSC/GELCC/G2FamiliesWithG2per.10.4.21.csv")

                                    # map <- read.delim(file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/10.5.21.map") # nrow(map) # = 876

# because .map and .ped must match in exact names and order, I am going to use the map$marker_name to create the .ped 
# changed map to just be the marker, now making 2 allele columns for each marker in ped # this didn't work: alleles <- paste(map$marker_name, c("_1", "_2"), sep="")
alleles <- vector()
for(i in map$marker_name) { # i= map$marker_name[7]
    alleles <- append(alleles, c(paste(i, "_1", sep=""), paste(i, "_2", sep="")))
    } # for i
                            # G2FamiliesWithG2per[which(G2FamiliesWithG2per$num_affected == max(G2FamiliesWithG2per$num_affected)),] # =  "HLA-DRB5"

ped <- data.frame(matrix(nrow = 0, ncol = 6 + length(alleles)))
colnames(ped) <- c("pid", "id", "fid", "mid", "sex", "aff", alleles)                      
# g <- "HLA-DRB5" # g <- "GOLGA8B"
i = 0                                                           # s = "H_NK-12GELCC38-12038"
for(s in unique(overlappingCNVsPostRemoved$sample)){ # s = overlappingCNVsPostRemoved$sample[grep(g , overlappingCNVsPostRemoved$XHMMgene)][1] # see g below
    i = i + 1
    ped[i,1] <- phenoFam[which(phenoFam$submitted.sample.id == s), "CID"]
    ped[i,2] <- phenoFam[which(phenoFam$submitted.sample.id == s), "CIND"]
    ped[i,3] <- phenoFam[which(phenoFam$submitted.sample.id == s), "CF"]
    ped[i,4] <- phenoFam[which(phenoFam$submitted.sample.id == s), "CM"]
    ped[i,5] <- phenoFam[which(phenoFam$submitted.sample.id == s), "SEX"]
        aff <- phenoFam[which(phenoFam$submitted.sample.id == s), "diagnosis.of.lung.throat.pharynx.larynx.cancer"]
        if(aff) ped[i,6] <- 2 else ped[i,6] <- 0 ### here i could use whether CIND is deceased for 1 if they did not have cancer
        
      # this is where to loop through all genes to fill in genotype information  
      for(g in G2FamiliesWithG2per$gene){   # g =  G2FamiliesWithG2per$gene[20] # i = 112 # g = "SSX1"
                locate <- grepl(g, overlappingCNVsPostRemoved$XHMMgene[which(overlappingCNVsPostRemoved$sample == s)] )
                present <- any(locate)
                cn <- overlappingCNVsPostRemoved$GATKcall.copyNum[which(overlappingCNVsPostRemoved$sample == s)][which(locate)] 
                chr <- overlappingCNVsPostRemoved$chr[grep(g, overlappingCNVsPostRemoved$XHMMgene)[1]]
                  col1 <- paste(g, "_1", sep="")
                  col2 <- paste(g, "_2", sep="")
                   if(present && cn == 0) ped[i,col1] <- 2
                    # for copy number = 0 in male x chr, he has just one allele
                        if(present && cn == 0 && ped[i,5] == 1 && chr == 23) ped[i,col1] <- 1

                   if(present && cn == 1) ped[i,col1] <- 1
                   # if(cn == 2) cat("something is wrong here\n")
                   if(!present) ped[i,col1] <- 0
                   
                   # now for gene_2 (the non-deletion allele)
                   if(present && cn == 0) ped[i,col2] <- 0
                   if(present && cn == 1) ped[i,col2] <- 1
                   if(!present) ped[i,col2] <- 2                  
                   if(!present && ped[i,5] == 1 && chr == 23) ped[i,col2] <- 1 
                 } # for g   
              cat("individual ", s, " is number ", i, "\n")      
                    
         } # for s 
# replace CID = New with number (242)
max(as.numeric(ped$pid[-grep("New", ped$pid)])) # = 135
ped$pid[grep("New", ped$pid)] <- 242

# write.table(ped, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/correctedX176genesG2FamG2per10.15.21.ped", quote=FALSE, col.names =FALSE, row.names=FALSE, sep="\t")

# This won't work but to know where it came from: # wrote ped where SSX1 deletion in CID = 12, CIND = 38 copyNum is 1 instead of 2 # write.table(ped, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/ChangedSSX1IN12038oneMarkerPerTwoAlleles197genesG2FamG2per10.12.21.ped", quote=FALSE, col.names =FALSE, row.names=FALSE, sep="\t")

# load these files
# map <- read.delim (file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/176.G2FamG2per10.15.21.map")
# colnames(map) <- c("marker_name", "chr#", "genetic_pos", "physical_pos", "sex_link")
# ped <- read.delim(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/correctedX176genesG2FamG2per10.15.21.ped")
# colnames(ped) <- c("pid", "id", "fid", "mid", "sex", "aff", alleles) # alleles made above by adding _1 & _2 to map_marker

#!!!!!!!!!!!!!!!!! ped[which(ped$pid==12),c(1:6,grep("SSX1", colnames(ped)))]

unique(phenoFam$CID)
ped[which(ped$pid== 131),c(1:6, grep("CLPSL1", colnames(ped)))]
# load(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/10.15.21.upToAllDataOrganizedByGeneWithGeneListsByFilterSteps.rda")
#####################################################################################################################
# remake and update pheno and pedigree file
# load(file = "C:/Users/4wald/OneDrive - LSUHSC/GELCC/CNVsFrom3AlgsAndPhenoAndPhenoFam.2.19.2021.rda")
pheno <- read.csv(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/Pedigrees for WES for John - All Pedigrees.csv")

Phenotype Data File 
First line: names of all traits in the phenotype file
Remaining lines: pid id trait 1 trait 2 ...
# consider using SRNA (self report nonaffected) and FRNA (fmaily report of nonaffected status) 
# C1/2 --> cancer type 1 or 2 by age at diagnosis # AO1/2 means age at onset of C1/2

phe <- subset(pheno, select = colnames(pheno) %in% c("CID", "CIND", "AFF_ANY_M", "AFF_LT_M1", "AFF-L", "C1", "C2", "SMOKE", "PY", "CYPR", "CC1", "CC2", "AO1", "AO2"))

colnames(phe) <- c("pid", "id", "anyMalignancy", "lungTracheaMalignancy", "C1", "C2", "CC1", "CC2", "ageOnset1", "ageOnset2", "packyears", "smoker")

# replace CID = New with number (242)
# max(as.numeric(phe$pid[-grep("New", phe$pid)])) # = 135
phe$pid[grep("New", phe$pid)] <- 242

# changes 1 (unaffected) under malignancy to 0 for unknown
phe$anyMalignancy[grep(1, phe$anyMalignancy)] <- 0
phe$lungTracheaMalignancy[grep(1, phe$lungTracheaMalignancy)] <- 0

# replaceing "-" in packyears with 0
phe$packyears[grep("-", phe$packyears)] <- 0
phe$ageOnset1[grep("-", phe$ageOnset1)] <- 200

# saving only columns with numbers as values
phe <- phe[,c(1,2,3,4,9,11)]

# making colnames into the the list of traits and include it in the created table
# names prior to removing columns without number values: colnames(phe) <- c("anyMalignancy", "lungTracheaMalignancy", "C1", "C2", "CC1", "CC2", "ageOnset1", "ageOnset2", "packyears", "smoker","","")
colnames(phe) <- c("anyMalignancy", "lungTracheaMalignancy", "ageOnset1", "packyears","","")

write.table(phe, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/ageOnsetOf200.10.6.21.phe", quote=FALSE, row.names=FALSE, sep="\t")


#####################################################################################################################
# linkage analysis

###############################
# create SSX1 genotypes as bi allelic to combine with SNP data
# this is written so a linkage analysis input can quickly be made from any list of genes (not just SSX1) related to the data set. 

# load(file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/10.3.21.upToAllDataOrganizedByGene.rda")
# G2FamiliesWithG2per <- read.csv(file= "C:/Users/4wald/OneDrive - LSUHSC/GELCC/G2FamiliesWithG2per.10.4.21.csv")

# The map file uses the following format:
# marker_name chr# genetic_pos physical_pos sex_link
# The count of the markers and the order in which they are listed in the map file must be the same as in the ped file. 

# Chr# is set to 23 for an X-chromosome marker, and 24 for Y.
# Sex_link = 1 if the marker is sex linked, 0 otherwise. If sex_link = 1, fbat will implement an analysis for an x-chromosome
# marker. For autosomal markers, and for markers in the pseudoautosomal region of the x-marker, set sex-link to zero.

# necessary for "between()" function
 library(dplyr)

#changing no.olaps chr# from NA to no.olaps creates an error for IRanges in loops below,
# must remove the sample that had no XHMM and GATK overlaps from running through these loops
overlappingCNVsPostRemoved <- overlappingCNVsPostRemoved[-grep("no.olaps", overlappingCNVsPostRemoved$chr),]

# replace chr numbers with JUST numbers 23 for X, 24 for Y
    l <- strsplit(overlappingCNVsPostRemoved$chr, "chr")
    numb <- sapply(l, "[", 2)
    numb[which(numb=="X")] <- 23
    numb[which(numb=="Y")] <- 24
    overlappingCNVsPostRemoved$chr <- as.numeric(numb)
########################### create map ############################################
# use this variable to easily switch the df of segs from which the map file is created: must have segs and chr information
    seg.df <- overlappingCNVsPostRemoved # the gene list is what really limits the map file, this is just for information like chr and coordinates corresponding the genes chosen from the list

# use this variable to easily switch the filtered gene list to include in the map file
    filteredGenes <- "SSX1" ########## G2FamiliesWithG2per$gene

map <- as.data.frame(matrix(nrow=0, ncol=5))
colnames(map) <- c("marker_name", "chr", "genetic_pos", "physical_pos", "sex_link")

for (i in unique(seg.df$chr)){ # i = unique(seg.df$chr)[10] #overlappingCNVsPostRemoved[which(is.na(overlappingCNVsPostRemoved$chr)),]
    byChr <- subset(seg.df, seg.df$chr == i)
        # for each gene on chr i, determine how many nonoverlapping deletions have been identified. 
        # each nonoverlapping deletion will be listed as a different marker
        #clear segs
        segs <- vector()
        # create vector of genes in unique(unlist(strsplit(byChr$XHMMgene, ", "))) and in G2FamiliesWithG2per$gene # G2FamiliesWithG2per does not have chr info attached (future go back and add it, or now overlap with genes subset to this chr)
        limitedGenesInThisChr <- filteredGenes[which(filteredGenes %in% unique(unlist(strsplit(byChr$XHMMgene, ", "))))]
        for (j in limitedGenesInThisChr) { # j = limitedGenesInThisChr[5] 
                Ustart <- byChr$GATKstart[grep(j, byChr$XHMMgene)] 
                Uend <- byChr$GATKend[grep(j, byChr$XHMMgene)]
                sample <- byChr$sample[grep(j, byChr$XHMMgene)]
                segs <- cbind(start = as.numeric(Ustart), end = as.numeric(Uend))
                segs <- data.frame(sample = sample, chr = i, start = segs[,1], end = segs[,2], physicalPos = rowMeans(segs)) 
                A <- makeGRangesFromDataFrame(segs, keep.extra.columns=TRUE) 
                            # ABlaps <- findOverlaps(A, invert=TRUE)
                            # ABsect <- pintersect(A[queryHits(ABlaps)], B[subjectHits(ABlaps)])
                w <- A %outside% A # %outside% is the inverse of overlapsAny() or the convenience wrapper %over% 
                #initiate and clear imap for each j before running through k
                imap <- as.data.frame(matrix(nrow=0, ncol=5))
                colnames(map) <- c("marker_name", "chr", "genetic_pos", "physical_pos", "sex_link")    
                for (p in 1:(length(which(w))+1)){ # p = 1 ## intended to be unique non overlapping segments!!!!!!!!!!!!!!!!!
                         if(p > 1) n <- paste(j, p, sep="") else n <- j
                         imap <- rbind(imap, data.frame(
                                       marker_name = n, 
                                       chr = i,
                                       genetic_pos = round(segs$physicalPos[p]), 
                                       physical_pos = round(segs$physicalPos[p]),
                                       sex_link = 0))
                                        ########################### previous # produces marker_1 only###############################################
                                        #imap <- rbind(imap, data.frame(marker_name = paste(j, p, sep="_"),  chr = i, genetic_pos = round(segs$physicalPos[p]), physical_pos = round(segs$physicalPos[p]), sex_link = 0))
                                        # previuos produces 2 markers
                                        # imap <- rbind(imap, data.frame(marker_name = paste(j, c(p, p+1), sep="_"), chr = c(i,i), genetic_pos = c(round(segs$physicalPos[p]), round(segs$physicalPos[p])),  physical_pos = c(round(segs$physicalPos[p]),round(segs$physicalPos[p])), sex_link = c(0,0)))
                                        ############################################################################################################                          
                   } # for p
            if(i == 23 | i == 24) sl = 1 else sl = 0
            imap$sex_link <- sl
            map <- rbind(map, imap)
            } # for j
      
       } # for i

write.table(SSX1map, file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/SSX1.map", quote = FALSE, col.names = FALSE, row.names = FALSE, sep = "\t")
##########################################################################################################################
# linkage analysis input
# because .map and .ped must match in exact names and order, I am going to use the map$marker_name to create the .ped 
# Need 2 allele columns for each marker = bi allelic
alleles <- vector()
for(i in map$marker_name) { # i= map$marker_name[7]
    alleles <- append(alleles, c(paste(i, "_1", sep=""), paste(i, "_2", sep="")))
    } # for i
                            
#temporarily subsetting phenoFam to only family 12
phenoFam <- subset(phenoFam, phenoFam$CID == 12)
# temporarily subsetting overlappingCNVsPostRemoved to family 12
overlappingCNVsPostRemoved <- subset(overlappingCNVsPostRemoved,  overlappingCNVsPostRemoved$sample %in% phenoFam$submitted.sample.id)


ped <- data.frame(matrix(nrow = 0, ncol = 6 + length(alleles)))
colnames(ped) <- c("pid", "id", "fid", "mid", "sex", "aff", alleles)                      
# g <- "HLA-DRB5" # g <- "GOLGA8B"
i = 0                                                           # s = "H_NK-12GELCC38-12038"
for(s in unique(overlappingCNVsPostRemoved$sample)){ # s = overlappingCNVsPostRemoved$sample[grep(g , overlappingCNVsPostRemoved$XHMMgene)][1] # see g below
    i = i + 1
    ped[i,1] <- phenoFam[which(phenoFam$submitted.sample.id == s), "CID"]
    ped[i,2] <- phenoFam[which(phenoFam$submitted.sample.id == s), "CIND"]
    ped[i,3] <- phenoFam[which(phenoFam$submitted.sample.id == s), "CF"]
    ped[i,4] <- phenoFam[which(phenoFam$submitted.sample.id == s), "CM"]
    ped[i,5] <- phenoFam[which(phenoFam$submitted.sample.id == s), "SEX"]
        aff <- phenoFam[which(phenoFam$submitted.sample.id == s), "diagnosis.of.lung.throat.pharynx.larynx.cancer"]
        if(aff) ped[i,6] <- 2 else ped[i,6] <- 0 ### here i could use whether CIND is deceased for 1 if they did not have cancer
        
      # this is where to loop through all genes to fill in genotype information  
      for(g in filteredGenes){   # g =  G2FamiliesWithG2per$gene[20] # i = 112 # g = "SSX1"
                locate <- grepl(g, overlappingCNVsPostRemoved$XHMMgene[which(overlappingCNVsPostRemoved$sample == s)] )
                present <- any(locate)
                cn <- overlappingCNVsPostRemoved$GATKcall.copyNum[which(overlappingCNVsPostRemoved$sample == s)][which(locate)] 
                chr <- overlappingCNVsPostRemoved$chr[grep(g, overlappingCNVsPostRemoved$XHMMgene)[1]]
                  col1 <- paste(g, "_1", sep="")
                  col2 <- paste(g, "_2", sep="")
                   if(present && cn == 0) ped[i,col1] <- 2
                    # for copy number = 0 in male x chr, he has just one allele
                        if(present && cn == 0 && ped[i,5] == 1 && chr == 23) ped[i,col1] <- 1

                   if(present && cn == 1) ped[i,col1] <- 1
                   # if(cn == 2) cat("something is wrong here\n")
                   if(!present) ped[i,col1] <- 0
                   
                   # now for gene_2 (the non-deletion allele)
                   if(present && cn == 0) ped[i,col2] <- 0
                   if(present && cn == 1) ped[i,col2] <- 1
                   if(!present) ped[i,col2] <- 2                  
                   if(!present && ped[i,5] == 1 && chr == 23) ped[i,col2] <- 1 
                 } # for g   
              cat("individual ", s, " is number ", i, "\n")      
                    
         } # for s 

# write.table(ped, file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/SSX1biallelic.txt", quote=FALSE, col.names = TRUE, row.names=FALSE, sep="\t")


###########################################################################################################


###############################################################################################################################

Make pedigree for family 131
# install.packages('kinship2')
library(kinship2) ## fixParents() # could be a helpful function (for all of us)

# load phenoFam  # write.csv(phenoFam, file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/phenoFam.csv", row.names=FALSE) # load(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/XHMMcnvAndGATKcnvWithQAandQS.rda")
   phenoFam <- read.csv(file="C:/Users/4wald/OneDrive - LSUHSC/GELCC/phenoFam.csv")
# load all pedigree information
    pheno <- read.csv(file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/Pedigrees for WES for John - All Pedigrees.csv")
    

# use fam variable to choose the family of interest # pheno[grep(fam, pheno$CID), 1:12] # 
    for(fam in unique(phenoFam$CID)) { # e.g. fam <- 12 fam <- 131
        
        # define values for pedigree function
        i <- pheno[which(pheno$CID==fam),"CIND"]
        dad <- pheno[which(pheno$CID==fam),"CF"]
        mom <- pheno[which(pheno$CID==fam),"CM"]
        s <- pheno[which(pheno$CID==fam),"SEX"]
        # pedigree just straight-up won't take 1 or 2 for male or female, numeric or string, just won't do it.
            s <- gsub(1, "male", s)
            s <- gsub(2, "female", s)

            aff <- pheno[which(pheno$CID==fam),"AFF_ANY_M"] # affected by any malignancy for now, CAN HAVE UP TO 4 COLUMNS
                 WES <- pheno[which(pheno$CID==fam), "CIND"] %in% phenoFam[which(phenoFam$CID==fam), "CIND"]
                 WES <- gsub(TRUE, 2, WES)
                 WES <- gsub(FALSE, 1, WES)\
            aff <- as.matrix(cbind(as.numeric(aff), as.numeric(WES)))
                        
                        pdf <- data.frame(id = i, dadid = dad, momid = mom, sex = s, affected = aff, missid = 0)
                        # subset pdf to only those ID that need to be included
                        pdf <- subset(pdf, pdf$id %in% c(37, 38, 43, 11, 22, 7, 44, 20, 45, 6, 10, 29, 9, 6, 7, 44, 20, 18, 19, 13, 12))
            p <- pedigree(id = pdf$id, dadid = pdf$dadid, momid = pdf$momid, sex = pdf$sex, affected = as.matrix(pdf[,5:6]), missid = 0)
                       
    # shrink1 <- pedigree.shrink(ped=p, affected = aff, avail=aff[,2], maxBits=25)
    # plot(shrink1)
    
    # pdf device is best for resizing. printing plot to devide will be necessary to save images.
            pdf(file=paste("C:/Users/4wald/OneDrive - LSUHSC/GELCC/pedigree", fam, ".pdf", sep=""), title = paste("Family", fam))

                plot(p, id = p$id, affected = as.matrix(pdf[,5:6]), 
                                 cex = 1, col = c(2), symbolsize = 1, branch =
                                 0.9, packed = TRUE, align = c(1.5,2), width = 8,
                                 density = c(-1, 35, 65, 20), mar = c(4.1, 1, 4.1, 1),
                                 angle = c(90, 65, 40, 0), keep.par = FALSE, 
                                 pconnect= .5)
                legendPlot(p, id=p$id, affected=aff, affected.label=c("malignancy", "WES"),
                           col=1, col.label=NULL, symbolsize=.75)
             dev.off()

            } # fam -loop for all families

# family 12 for progeny
pheno <- read.csv(file="C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/Pedigrees for WES for John - All Pedigrees.csv")
write.csv(pheno[which(pheno$CID==12),], file = "C:/Users/jwaldr/OneDrive - LSUHSC/GELCC/Family12PhenoFam.csv")

############################## format for pedigree ##############################
pedigree(id, dadid, momid, sex, affected, status, relation, famid, missid)

plot(x, id = x$id, status = x$status, affected =
                 x$affected, cex = 1, col = 1, symbolsize = 1, branch =
                 0.6, packed = TRUE, align = c(1.5,2), width = 8,
                 density = c(-1, 35, 65, 20), mar = c(4.1, 1, 4.1, 1),
                 angle = c(90, 65, 40, 0), keep.par = FALSE, subregion,
                 pconnect= .5, …)
legendPlot(x, id=x$id, affected=x$affected, affected.label=NULL,
           col=1, col.label=NULL, symbolsize=.75, …)
